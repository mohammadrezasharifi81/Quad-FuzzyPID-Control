\documentclass[12pt, a4paper]{report}
% ------------------ بسته‌ها ------------------
\usepackage{fontspec}
\usepackage{graphicx}
\usepackage{tocloft}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{subcaption}
\usepackage{float}
\usepackage{longtable}
\usepackage{amsmath}
\usepackage{xcolor}
\usepackage{array}
\usepackage{booktabs}
\usepackage[a4paper, left=2.5cm, right=3cm, top=3cm, bottom=2.5cm]{geometry}
\usepackage{setspace}
\onehalfspacing
\usepackage[sort,numbers]{natbib}
\usepackage[colorlinks=true, linkcolor=black, citecolor=blue, urlcolor=blue]{hyperref}
% -------------------------------------------
\usepackage{zref-perpage} % شمارش مجدد برای هر صفحه
\zmakeperpage{footnote}  % اعمال روی پاورقی
\usepackage{xepersian}

% ------------------ تنظیمات  ------------------
\renewcommand{\thefootnote}{\arabic{footnote}}
\renewcommand{\cftchapleader}{\cftdotfill{\cftdotsep}}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}
% ------------------ فونت‌ها ------------------
\settextfont[Path=FontLogo/, BoldFont=BNazaninBd.TTF]{BNazanin.TTF}
\setlatintextfont[Scale=1]{Times New Roman}
% ------------------ هدر و فوتر ------------------
\pagestyle{fancy}
\fancyhf{} 
\fancyhead[L]{\thepage} 
\fancyhead[R]{\leftmark} 
\setlength{\headheight}{15pt}

% ---------------------------------------------------------------------------
\usepackage{longtable}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{array}

% For better table layout
\renewcommand{\arraystretch}{1.5}
\newcolumntype{L}{>{$}l<{$}} % Math mode left-aligned
\newcolumntype{M}{>{$}c<{$}} % Math mode center-aligned
\newcolumntype{R}{m{8cm}}    % Description column with fixed width
\usepackage{multirow}
\usepackage{array}
\usepackage{geometry}
\renewcommand{\arraystretch}{1.5}
% ------------------ هدر فصل ------------------
\renewcommand{\chaptermark}[1]{\markboth{فصل \thechapter ~:~ #1}{}}
% ====================================================
\begin{document}
\input{TitlePage}

\thispagestyle{empty}
\begin{figure}[p]
    \centering
    \makebox[0pt][c]{\includegraphics[width=0.8\paperwidth,height=0.8\paperheight,keepaspectratio=true]{FontLogo/BESM.jpg}}
\end{figure}

% ------------------ فهرست ------------------
\cleardoublepage
\phantomsection
\tableofcontents

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{فهرست تصاویر}
\listoffigures

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{فهرست جداول}
\listoftables

\cleardoublepage
\phantomsection
\chapter*{فهرست علائم و نشانه‌ها}
\addcontentsline{toc}{chapter}{فهرست علائم و نشانه‌ها}
\begin{longtable}{|M|R|}
\caption{فهرست جامع علائم و نمادها برای مدل‌سازی و کنترل کوادروتور 6 درجه آزادی} \label{tab:symbols} \\
\hline
\multicolumn{1}{|c|}{\textbf{نماد}} & \multicolumn{1}{c|}{\textbf{توضیحات}} \\
\hline
\endfirsthead

\multicolumn{2}{c}%
{{\tablename\ \thetable{}: ادامه از صفحه قبل}} \\
\hline
\multicolumn{1}{|c|}{\textbf{نماد}} & \multicolumn{1}{c|}{\textbf{توضیحات}} \\
\hline
\endhead

\hline \multicolumn{2}{|r|}{{ادامه در صفحه بعد}} \\ \hline
\endfoot

\hline
\endlastfoot

%====================================================================
% بخش اول: متغیرهای حالت و سینماتیک (دینامیک 6 درجه آزادی)
%====================================================================
\multicolumn{2}{|c|}{\textbf{بخش ۱: متغیرهای حالت و سینماتیک}} \\
\hline
I & چارچوب مرجع اینرسی یا جهانی (\lr{Inertial Frame}) \\
\hline
B & چارچوب مرجع متصل به بدنه (\lr{Body Frame}) \\
\hline
\xi = [x, y, z]^T & بردار موقعیت خطی مرکز جرم کوادروتور در چارچوب اینرسی. \\
\hline
\eta = [\phi, \theta, \psi]^T & بردار وضعیت زاویه‌ای (زوایای اویلر) در چارچوب اینرسی. \\
\phi & زاویه غلتش ($Roll$) حول محور $x$ بدنه. \\
\theta & زاویه پیچش ($Pitch$) حول محور $y$ بدنه. \\
\psi & زاویه انحراف ($Yaw$) حول محور $z$ بدنه. \\
\hline
\nu = [u, v, w]^T & بردار سرعت خطی در چارچوب بدنه. \\
\hline
\dot{\xi} = [\dot{x}, \dot{y}, \dot{z}]^T & بردار سرعت خطی در چارچوب اینرسی. \\
\hline
\Omega = [p, q, r]^T & بردار سرعت زاویه‌ای در چارچوب بدنه. \\
p & سرعت زاویه‌ای حول محور $x$ بدنه (سرعت غلتش). \\
q & سرعت زاویه‌ای حول محور $y$ بدنه (سرعت پیچش). \\
r & سرعت زاویه‌ای حول محور $z$ بدنه (سرعت انحراف). \\
\hline
R & ماتریس دوران برای تبدیل از چارچوب بدنه به چارچوب اینرسی. \\
\hline

%====================================================================
% بخش دوم: پارامترهای فیزیکی، نیروها و گشتاورها
%====================================================================
\multicolumn{2}{|c|}{\textbf{بخش ۲: پارامترهای فیزیکی، نیروها و گشتاورها}} \\
\hline
m & جرم کل کوادروتور (واحد: $kg$). \\
\hline
g & شتاب گرانش (واحد: $m/s^2$). \\
\hline
I = \text{$diag$}(I_{xx}, I_{yy}, I_{zz}) & تانسور اینرسی کوادروتور حول مرکز جرم. \\
I_{xx}, I_{yy}, I_{zz} & ممان‌های اینرسی حول محورهای اصلی $x$, $y$, $z$ بدنه. \\
\hline
l & فاصله مرکز هر موتور تا مرکز جرم کوادروتور (طول بازو). \\
\hline
\omega_i & سرعت زاویه‌ای موتور $i$-ام ($i$=1,2,3,4) (واحد:$ rad/s$). \\
\hline
T_i = k_T \omega_i^2 & نیروی تراست (پیشران) تولیدی توسط موتور $i$-ام. \\
\hline
T = \sum_{i=1}^{4} T_i & مجموع نیروی تراست کل در راستای محور $z$ بدنه. \\
\hline
D_i = k_D \omega_i^2 & گشتاور پسار (\lr{Drag Torque}) تولیدی توسط موتور $i$-ام. \\
\hline
k_T \text{ $or$ } b & ضریب تراست موتورها. \\
\hline
k_D \text{ $or$ } d & ضریب پسار (درگ) موتورها. \\
\hline
\tau = [\tau_{\phi}, \tau_{\theta}, \tau_{\psi}]^T & بردار گشتاورهای کنترلی اعمالی به بدنه. \\
\tau_{\phi} & گشتاور کنترلی حول محور $x$ (گشتاور غلتش). \\
\tau_{\theta} & گشتاور کنترلی حول محور $y$ (گشتاور پیچش). \\
\tau_{\psi} & گشتاور کنترلی حول محور $z$ (گشتاور انحراف). \\
\hline

%====================================================================
% بخش سوم: ورودی‌های کنترلی
%====================================================================
\multicolumn{2}{|c|}{\textbf{بخش ۳: ورودی‌های کنترلی}} \\
\hline
U_1 & ورودی کنترلی متناظر با مجموع نیروی تراست کل ($T$). \\
\hline
U_2 & ورودی کنترلی متناظر با گشتاور غلتش ($\tau_{\phi}$). \\
\hline
U_3 & ورودی کنترلی متناظر با گشتاور پیچش ($\tau_{\theta}$). \\
\hline
U_4 & ورودی کنترلی متناظر با گشتاور انحراف ($\tau_{\psi}$). \\
\hline
\begin{bmatrix} U_1 \\ U_2 \\ U_3 \\ U_4 \end{bmatrix} = \begin{bmatrix} ... \end{bmatrix} \begin{bmatrix} \omega_1^2 \\ \omega_2^2 \\ \omega_3^2 \\ \omega_4^2 \end{bmatrix} & رابطه ماتریسی بین ورودی‌های کنترلی و مربع سرعت زاویه‌ای موتورها. \\
\hline

%====================================================================
% بخش چهارم: کنترل‌کننده PID استاندارد
%====================================================================
\multicolumn{2}{|c|}{\textbf{بخش ۴: کنترل‌کننده $PID$ استاندارد}} \\
\hline
r(t) \text{ $or$ } x_d(t) & مقدار مطلوب یا نقطه تنظیم (\lr{Setpoint/Reference}). \\
\hline
y(t) \text{ $or$ } x(t) & مقدار اندازه‌گیری شده یا واقعی فرآیند \lr{(Measured Value)}. \\
\hline
e(t) = r(t) - y(t) & سیگنال خطا. \\
\hline
K_p & بهره تناسبی (\lr{Proportional Gain}). \\
\hline
K_i & بهره انتگرالی (\lr{Integral Gain}). \\
\hline
K_d & بهره مشتقی (\lr{Derivative Gain}). \\
\hline
u(t) & خروجی کنترل‌کننده $PID$. \\
\hline
u(t) = K_p e(t) + K_i \int_0^t e(\tau)d\tau + K_d \frac{de(t)}{dt} & معادله استاندارد کنترل‌کننده $PID$. \\
\hline

\end{longtable}


\newpage
\chapter{مقدمه}
در گذار به عصر فناوری‌های هوشمند و سیستم‌های خودران، وسایل نقلیه هوایی بدون سرنشین، و در میان آن‌ها کوادروتورها، نقشی کلیدی و انکارناپذیر یافته‌اند. این پرنده‌ها که زمانی عمدتاً در حوزه سرگرمی و پژوهش‌های آکادمیک محدود بودند، اکنون به سرعت در حال تبدیل شدن به ستون فقرات صنایع آینده‌نگر، از جمله لجستیک هوشمند، نظارت بر زیرساخت‌های حیاتی، کشاورزی دقیق و عملیات‌های امداد و نجات هستند. این جهش کاربردی، ریشه در یک ویژگی دوگانه و جذاب دارد: ساختار مکانیکی به ظاهر ساده که کنترل آن تنها از طریق تغییر سرعت روتورها صورت می‌پذیرد ، در حالی که در پس این سادگی، یک دینامیک پرواز بسیار پیچیده، غیرخطی و چالش‌برانگیز نهفته است. همین ماهیت دوگانه، کوادروتور را به بستری ایده‌آل برای توسعه و اعتبارسنجی پیشرفته‌ترین نظریه‌های مهندسی کنترل تبدیل کرده است.

با این حال، انتقال موفقیت‌آمیز کوادروتورها از محیط‌های کنترل‌شده آزمایشگاهی به دنیای واقعی، با یک مانع اساسی روبروست: عدم قطعیت. مدل ریاضی که برای توصیف حرکت شش درجه آزادی این پرنده به کار می‌رود، هرچقدر هم که دقیق باشد، همواره تقریبی از واقعیت است. در عمل، کوادروتور با مجموعه‌ای از عدم قطعیت‌های داخلی و اغتشاشات خارجی مواجه است. تغییرات پیش‌بینی‌نشده در پارامترهای کلیدی مانند جرم و اینرسی به دلیل حمل بارهای متغیر ، و همچنین دینامیک‌های مدل‌سازی‌نشده مانند اثرات آیرودینامیکی پیچیده ، عملکرد سیستم را تحت تأثیر قرار می‌دهند. مهم‌تر از آن، اغتشاشات خارجی و غیرقابل پیش‌بینی، به ویژه تندبادها و تلاطم‌های جوی، به دلیل نسبت نیروی پیشران به وزن پایین این پرنده‌ها، می‌توانند به سادگی پایداری آن‌ها را مختل کرده و منجر به انحراف شدید از مسیر مطلوب شوند. بنابراین، مسئله اصلی دیگر صرفاً پایدارسازی یک مدل ایده‌آل نیست، بلکه تضمین عملکرد مقاوم، ایمن و قابل اعتماد در یک محیط عملیاتی پویا و نامشخص است.

ضرورت انجام این پژوهش دقیقاً از همین نقطه برمی‌خیزد. علی‌رغم پیشرفت‌های گسترده در حوزه کنترل کوادروتور، شکاف‌های قابل توجهی میان نظریه و عمل باقی مانده است. اولاً، فقدان یک چارچوب استاندارد برای محک‌زنی و مقایسه منصفانه راهبردهای کنترلی مختلف، پیشرفت این حوزه را با چالش مواجه کرده است. بسیاری از نتایج منتشرشده به دلیل تفاوت در شرایط آزمایشی، سخت‌افزار و معیارهای ارزیابی، قابل تکرار یا مقایسه مستقیم نیستند. ثانياً، بسیاری از کنترل‌کننده‌ها برای مانورهای تهاجمی و پرواز در محیط‌های ناشناخته و پیچیده، که برای کاربردهای نسل آینده حیاتی است، طراحی نشده‌اند. و در نهایت، با حرکت به سمت الگوریتم‌های کنترلی پیچیده‌تر و مبتنی بر داده، مسئله ایمنی، تأییدپذیری و صدور گواهینامه به یک مانع بزرگ، به ویژه برای کاربردهای ایمنی-بحرانی، تبدیل شده است. این پروژه با تمرکز بر طراحی و تحلیل یک کنترل‌کننده مقاوم، تلاشی است در جهت پاسخ به این نیازها و کاهش شکاف میان عملکرد تئوری و قابلیت اطمینان عملی.

برای مقابله با این چالش‌ها، راهبردهای کنترلی در طول زمان تکامل یافته‌اند. رویکردهای اولیه که بر پایه مدل‌های خطی‌شده سیستم بنا شده بودند، هرچند ابزارهای تحلیلی قدرتمندی را فراهم می‌کردند، اما در شرایط پروازی دور از نقطه تعادل، کارایی خود را از دست می‌دادند. این محدودیت، محققان را به سمت توسعه روش‌های غیرخطی سوق داد که مستقیماً با ذات پیچیده دینامیک سیستم روبرو می‌شوند و مقاومت بیشتری در برابر عدم قطعیت‌ها ارائه می‌دهند. نسل جدیدتر کنترل‌کننده‌ها حتی یک گام فراتر رفته و به جای سرکوب، به طور فعال به تخمین، یادگیری و تطبیق خود با تغییرات سیستم و محیط می‌پردازند. امروزه، اجماع فزاینده‌ای در جامعه علمی وجود دارد که آینده کنترل با عملکرد بالا، در معماری‌های کنترلی ترکیبی نهفته است؛ سیستم‌هایی که به طور هوشمندانه نقاط قوت فلسفه‌های مختلف کنترلی را برای غلبه بر ضعف‌های فردی آن‌ها با یکدیگر ادغام می‌کنند.

این گزارش به صورت نظام‌مند برای تحلیل این مسئله و ارائه یک راهکار ساختار یافته است. فصل دوم به مرور عمیق ادبیات تحقیق اختصاص دارد، جایی که سیر تکامل رویکردهای کنترلی از مدل‌های کلاسیک تا پارادایم‌های مدرن بررسی شده و با نگاهی انتقادی، چالش‌ها و شکاف‌های پژوهشی کلیدی که محرک اصلی این پروژه بوده‌اند، شناسایی می‌شوند. در فصل سوم، بر اساس تحلیل‌های صورت گرفته، یک معماری کنترل مقاوم مشخص انتخاب شده و مبانی نظری، ویژگی‌ها و مزایای آن به تفصیل تشریح می‌گردد. فصل چهارم به بخش عملی پروژه می‌پردازد و فرآیند شبیه‌سازی کنترل‌کننده منتخب را در محیط نرم‌افزاری متلب/سیمولینک به نمایش می‌گذارد تا عملکرد آن تحت سناریوهای مختلف ارزیابی شود. در فصل پنجم، ملاحظات و چالش‌های پیاده‌سازی این الگوریتم بر روی سخت‌افزار واقعی مورد بحث قرار می‌گیرد که گامی حیاتی برای اعتبارسنجی نهایی است. در نهایت، فصل ششم با ارائه یک نتیجه‌گیری جامع از یافته‌های پروژه و ترسیم چشم‌اندازهای تحقیقاتی آینده، این گزارش را به پایان می‌رساند.
 

\newpage
\chapter{مرور ادبیات}
\section{کوادروتور به عنوان یک بستر پژوهشی چالش‌برانگیز در حوزه کنترل}
\subsection{اهمیت و کاربردهای روزافزون کوادروتورها}
در دهه‌های اخیر، وسایل نقلیه هوایی بدون سرنشین\LTRfootnote{Unmanned Aerial Vehicles (UAVs)} از یک فناوری عمدتاً نظامی و سرگرمی به ابزاری حیاتی در طیف گسترده‌ای از کاربردهای غیرنظامی و صنعتی تبدیل شده‌اند \cite{zulu2024review, shraim2018survey}. در میان انواع مختلف \lr{UAV}ها، کوادروتورها\LTRfootnote{Quadrotors} به دلیل ویژگی‌های منحصربه‌فرد خود، توجه ویژه‌ای را در جوامع علمی و صنعتی به خود جلب کرده‌اند. این وسایل نقلیه، که نوع خاصی از هواگردهای بالگردان\LTRfootnote{Rotary-wing aircraft} هستند، به دلیل سادگی مکانیکی نسبی، قابلیت برخاست و فرود عمودی\LTRfootnote{Vertical Take-Off and Landing (VTOL)}، و توانایی شناوری\LTRfootnote{Hovering} در یک نقطه ثابت، انعطاف‌پذیری عملیاتی بالایی از خود نشان می‌دهند \cite{mian2021review, salih2022modeling, zulu2024review, abdulmajeed2022review}. این ویژگی‌ها، کوادروتورها را برای کاربردهایی نظیر فیلم‌برداری هوایی، بازرسی زیرساخت‌های حیاتی (مانند خطوط لوله و پل‌ها)، کشاورزی دقیق، عملیات جستجو و نجات، نظارت و پایش محیطی، و حتی لجستیک و تحویل کالا به گزینه‌ای ایده‌آل بدل کرده است \cite{zhang2022review, maaruf2022survey, shraim2018survey, zulu2024review}.
رشد تصاعدی مقالات پژوهشی و افزایش علاقه عمومی به این فناوری، همانطور که در روندهای جستجوی جهانی نیز مشهود است، گواهی بر اهمیت روزافزون کوادروتورهاست \cite{ghadiok2023historical}. این محبوبیت، خود یک شمشیر دولبه برای پژوهشگران حوزه کنترل است. از یک سو، سادگی مکانیکی کوادروتور (کنترل آن تنها از طریق تغییر سرعت دورانی روتورها انجام می‌شود.) آن را به یک پلتفرم در دسترس و کم‌هزینه برای آزمایش تئوری‌های کنترل تبدیل کرده است \cite{zulu2024review, abdulmajeed2022review}. از سوی دیگر، این سادگی ظاهری، یک پیچیدگی دینامیکی عمیق را پنهان می‌کند که چالش‌های کنترلی قابل توجهی را به همراه دارد. همین ماهیت دوگانه، یعنی دسترسی فیزیکی آسان و چالش‌های کنترلی عمیق، کوادروتور را از یک ابزار کاربردی صرف به یک موضوع پژوهشی بنیادی در علم کنترل تبدیل کرده است که بستر مناسبی برای توسعه و اعتبارسنجی الگوریتم‌های کنترلی پیشرفته فراهم می‌آورد \cite{mian2021review, zulu2024review, zulu2014review}.

\subsection{مدل‌سازی ریاضی و دینامیک پرواز شش درجه آزادی}
برای طراحی هر کنترل‌کننده مبتنی بر مدلی\LTRfootnote{Model-based controller}، درک دقیق و مدل‌سازی ریاضی رفتار دینامیکی سیستم، یک پیش‌نیاز اساسی است. دینامیک یک کوادروتور معمولاً با یک مدل صلب شش درجه آزادی\LTRfootnote{6-Degrees of Freedom (6-DOF)} توصیف می‌شود که حرکت آن در فضا را به‌طور کامل بیان می‌کند \cite{salih2022modeling, zulu2024review}. این مدل ریاضی عموماً با استفاده از فرمالیسم نیوتن-اویلر\LTRfootnote{Newton-Euler formalism} یا لاگرانژ-اویلر\LTRfootnote{Euler-Lagrange formalism} استخراج می‌شود \cite{salih2022modeling, tran2025design, zhang2023control}.
حالت\LTRfootnote{State} یک کوادروتور در هر لحظه با دوازده متغیر تعریف می‌شود: سه متغیر برای موقعیت خطی مرکز جرم در یک چارچوب مرجع اینرسی \lr{(x,y,z)}، سه متغیر برای سرعت خطی \lr{(x˙,y˙,z˙)}، سه متغیر برای توصیف وضعیت زاویه‌ای (رول\LTRfootnote{Roll ($\phi$)}، پیچ\LTRfootnote{Pitch (θ)}، و یاو\LTRfootnote{Yaw (ψ)}) در یک چارچوب متصل به بدنه، و سه متغیر برای سرعت زاویه‌ای \lr{(p,q,r)} \cite{nemati2014dynamic, zhang2023control}. دینامیک این سیستم دارای ویژگی‌های ذاتی است که آن را به یک مسئله کنترلی چالش‌برانگیز تبدیل می‌کند:

۱. سیستم کمتر-عملگر\LTRfootnote{Under-actuated System}: کوادروتور دارای شش درجه آزادی خروجی است، اما تنها چهار ورودی کنترلی مستقل (سرعت دورانی چهار روتور) برای کنترل این شش خروجی در اختیار دارد \cite{mian2021review, zhang2022review, salih2022modeling}. این بدان معناست که حرکات انتقالی در راستای محورهای \lr{x} و \lr{y} به‌طور مستقیم قابل کنترل نیستند و باید به‌صورت غیرمستقیم و از طریق تغییر زوایای رول و پیچ کنترل شوند.

۲. دینامیک شدیداً غیرخطی و کوپل‌شده\LTRfootnote{Highly Nonlinear and Coupled Dynamics}: معادلات حرکت کوادروتور شامل جملات غیرخطی قابل توجهی مانند توابع مثلثاتی زوایای اویلر، جملات درجه دوم سرعت‌های زاویه‌ای (ناشی از اثرات ژیروسکوپی و گشتاورهای آیرودینامیکی)، و کوپل\LTRfootnote{Coupling} قوی بین دینامیک انتقالی و دورانی است \cite{zhang2022review, salih2022modeling, zulu2014review}. این کوپل به این معناست که تغییر در وضعیت زاویه‌ای مستقیماً بر حرکت خطی تأثیر می‌گذارد و بالعکس.
به دلیل این ویژگی‌ها، مدل دینامیکی کوادروتور اغلب به دو زیرسیستم تقسیم می‌شود: یک زیرسیستم دورانی (شامل زوایای رول، پیچ و یاو) که کاملاً عملگر\LTRfootnote{Fully-actuated} است و یک زیرسیستم انتقالی (شامل موقعیت \lr{x,y,z}) که کمتر-عملگر است \cite{salih2022modeling, madani2006backstepping}. انتخاب نحوه نمایش وضعیت زاویه‌ای نیز یک تصمیم طراحی بنیادی با پیامدهای مستقیم برای عملکرد کنترل‌کننده است. در حالی که زوایای اویلر به دلیل ماهیت شهودی خود در بسیاری از مطالعات اولیه استفاده شده‌اند \cite{salih2022modeling, zhang2023control}، این نمایش در زوایای خاصی (مانند پیچ 90 درجه) دچار پدیده قفل گیمبال\LTRfootnote{Gimbal Lock} می‌شود که منجر به یک تکینگی\LTRfootnote{Singularity} ریاضی و از دست رفتن یک درجه آزادی می‌گردد. برای غلبه بر این محدودیت و امکان‌پذیر ساختن مانورهای تهاجمی\LTRfootnote{Aggressive maneuvers}، پژوهش‌های پیشرفته‌تر به استفاده از کواترنیون‌ها\LTRfootnote{Quaternions} روی آورده‌اند که نمایشی چهاربعدی و بدون تکینگی از وضعیت زاویه‌ای ارائه می‌دهند و برای کنترل در کل پوش پروازی\LTRfootnote{Flight envelope} ضروری هستند \cite{reyes2013lqr, mahfouz2025robust, lone2025improved}. این انتخاب، مستقیماً بر مقاومت و قابلیت اطمینان کنترل‌کننده در شرایط پروازی دینامیک تأثیر می‌گذارد.

\subsection{چالش‌های کلیدی در کنترل مقاوم}

هدف اصلی در طراحی یک سیستم کنترل پرواز برای کوادروتور، دستیابی به پایداری و ردیابی دقیق مسیرهای مطلوب است. با این حال، در دنیای واقعی، سیستم همواره با عدم قطعیت‌ها و اغتشاشاتی مواجه است که عملکرد آن را تهدید می‌کنند. بنابراین، نیاز به یک کنترل‌کننده مقاوم\LTRfootnote{Robust Controller} پدید می‌آید؛ کنترل‌کننده‌ای که بتواند عملکرد مطلوب خود را در حضور این پدیده‌های پیش‌بینی‌نشده حفظ کند \cite{abdulmajeed2022review, islam2015robust}. چالش‌های اصلی که یک کنترل‌کننده مقاوم باید بر آن‌ها غلبه کند، به دو دسته اصلی تقسیم می‌شوند:

\textbf{۱. عدم قطعیت‌های پارامتری و دینامیک‌های مدل‌سازی‌نشده}\LTRfootnote{Parametric Uncertainties and Unmodeled Dynamics}: مدل ریاضی که برای طراحی کنترل‌کننده استفاده می‌شود، همواره یک تقریب از سیستم واقعی است. عدم قطعیت‌های پارامتری شامل تغییرات در جرم و ماتریس اینرسی کوادروتور به دلیل حمل بارهای ناشناخته یا متغیر است \cite{vaidya2023dynamics, mahfouz2022adaptive, maaruf2022survey}. دینامیک‌های مدل‌سازی‌نشده نیز شامل اثرات آیرودینامیکی پیچیده (مانند نیروی درگ\LTRfootnote{Drag force} و اثر زمین\LTRfootnote{Ground effect}) است که در مدل‌های ساده‌شده نادیده گرفته می‌شوند اما در مانورهای سریع و تهاجمی تأثیر قابل توجهی دارند \cite{zhang2022review, omar2022recent}.

\textbf{۲. اغتشاشات خارجی}\LTRfootnote{External Disturbances}: این دسته شامل نیروها و گشتاورهای خارجی است که بر کوادروتور اعمال می‌شوند و مهم‌ترین آن‌ها تندبادها\LTRfootnote{Wind gusts} و تلاطم‌های جوی است. به دلیل نسبت نیروی پیشران به وزن پایین و سطح مقطع نسبتاً بزرگ، کوادروتورها به شدت تحت تأثیر باد قرار می‌گیرند که می‌تواند پایداری آن‌ها را به خطر اندازد و منجر به انحراف از مسیر مطلوب شود \cite{zhang2022review, islam2023robust, benevides2022disturbance}.
یک کنترل‌کننده مقاوم باید قادر باشد پایداری حلقه-بسته\LTRfootnote{Closed-loop stability} را تضمین کرده و خطای ردیابی را علی‌رغم وجود این دو منبع اصلی عدم قطعیت، در سطح قابل قبولی نگه دارد. این وظیفه، به‌ویژه برای کنترل‌کننده‌های خطی ساده که بر پایه یک مدل اسمی و در غیاب اغتشاشات طراحی شده‌اند، بسیار دشوار است \cite{vaidya2023dynamics, zhang2022review}. این چالش بنیادین، محرک اصلی برای تکامل راهبردهای کنترلی بوده و پژوهشگران را به سمت طراحی الگوریتم‌های پیچیده‌تر و هوشمندتر سوق داده است که در بخش‌های بعدی به تفصیل مورد بررسی قرار خواهند گرفت.

\newpage
\section{سیر تکامل راهبردهای کنترل: از خطی‌سازی تا یادگیری}
تاریخچه توسعه کنترل‌کننده‌ها برای کوادروتور، روایتی شفاف از یک فرآیند "مسئله-واکنش" است. محدودیت‌های هر نسل از کنترل‌کننده‌ها، مستقیماً انگیزه‌ای برای خلق نسل بعدی بوده است. این سیر تکاملی را می‌توان به سه دوره اصلی تقسیم کرد: دوره کنترل خطی، دوره ظهور کنترل غیرخطی و مقاوم، و دوره مدرن که با رویکردهای مبتنی بر تخمین و یادگیری مشخص می‌شود.
\subsection{تکنیک‌های کنترل خطی بنیادین}
اولین موج از کنترل‌کننده‌های طراحی‌شده برای کوادروتورها بر پایه یک فرض ساده‌کننده استوار بودند: خطی‌سازی دینامیک غیرخطی سیستم حول یک نقطه کار مشخص، که معمولاً حالت شناوری (\lr{hover}) است. این رویکرد، امکان استفاده از ابزارهای قدرتمند و شناخته‌شده تئوری کنترل خطی را فراهم می‌کرد.

\subsection*{کنترل‌کننده تناسبی-انتگرالی-مشتقی}
کنترل‌کننده \lr{PID}\LTRfootnote{Proportional-Integral-Derivative} به دلیل سادگی ساختاری، هزینه محاسباتی پایین و این واقعیت که تنظیم آن لزوماً به مدل دقیق سیستم نیاز ندارد، به پرکاربردترین کنترل‌کننده در صنعت و همچنین در پیاده‌سازی‌های اولیه کوادروتورها تبدیل شد \cite{mian2021review, li2011dynamic, zulu2024review}. مطالعات بنیادین متعددی، مانند کارهای بررسی‌شده توسط \lr{Li (2011)} \cite{zulu2024review} و \lr{Saleh (2022)} \cite{islam2023robust}، کارایی این کنترل‌کننده را در شبیه‌سازی و آزمایش‌های ساده برای دستیابی به شناوری پایدار و ردیابی مسیرهای ابتدایی نشان داده‌اند \cite{salih2022modeling, li2011dynamic}.

با این حال، محدودیت اصلی \lr{PID} دقیقاً در وابستگی آن به نقطه کار خطی‌شده نهفته است. هنگامی که کوادروتور مانورهای تهاجمی انجام می‌دهد یا تحت تأثیر اغتشاشات بزرگ قرار می‌گیرد، حالت سیستم از نقطه کار دور شده و رفتار غیرخطی آن غالب می‌شود. در این شرایط، عملکرد کنترل‌کننده \lr{PID} به شدت افت کرده و ممکن است منجر به ناپایداری شود \cite{mian2021review, zulu2024review}. علاوه بر این، فرآیند تنظیم بهره‌های \lr{PID} \lr{(Kp​,Ki​,Kd​)} اغلب به صورت تجربی و با روش آزمون و خطا انجام می‌شود که سیستماتیک نبوده و تضمینی برای بهینگی عملکرد ارائه نمی‌دهد \cite{mian2021review}.

\subsection*{تنظیم‌کننده خطی درجه دوم}
کنترل‌کننده \lr{LQR}\LTRfootnote{Linear Quadratic Regulator} یک گام فراتر از \lr{PID} است و یک رویکرد کنترل بهینه\LTRfootnote{Optimal control} را معرفی می‌کند. این روش به جای تنظیم دستی بهره‌ها، یک تابع هزینه را که ترکیبی از خطای حالت و تلاش کنترلی است، کمینه می‌سازد \cite{mian2021review, ercan2015lqr}. این ویژگی به طراح اجازه می‌دهد تا به صورت سیستماتیک یک مصالحه\LTRfootnote{Trade-off} بین دقت ردیابی و مصرف انرژی برقرار کند. \lr{LQR} به خوبی با سیستم‌های چند ورودی-چند خروجی \lr{(MIMO)}\LTRfootnote{Multi-Input Multi-Output} مانند کوادروتور سازگار است \cite{foehn2018state}.
یکی از کارهای کلیدی در این زمینه، پژوهش \lr{Reyes-Valeria et al. (2013)} است که در آن یک کنترل‌کننده \lr{LQR} بر پایه مدل خطی‌شده کواترنیونی طراحی شده و با استفاده از زمان‌بندی بهره\LTRfootnote{Gain Scheduling}، عملکرد آن در رژیم‌های پروازی مختلف بهبود یافته است \cite{reyes2013lqr, reyes2021lqr}. همچنین، مطالعه تأثیرگذار \lr{Bouabdallah et al. (2004)} یک مقایسه اولیه و مهم بین عملکرد \lr{PID} و \lr{LQR} ارائه داد و برتری نسبی \lr{LQR} را در شرایط خاص نشان داد \cite{suresh2017attitude}. با این وجود، \lr{LQR} نیز از محدودیت‌های ذاتی کنترل خطی رنج می‌برد. این روش همچنان به یک مدل خطی‌شده وابسته است و مقاومت آن در برابر عدم قطعیت‌های پارامتری بزرگ، محدود است \cite{suresh2017attitude}. همچنین، در غیاب یک جمله انتگرالی (که در کنترل‌کننده \lr{LQI} وجود دارد)، ممکن است در ردیابی مسیر دچار خطای حالت ماندگار\LTRfootnote{Steady-state error} شود \cite{mian2021review, castillo2021discrete}. شکست کنترل‌کننده‌های خطی در ارائه عملکرد قابل قبول در کل پوش پروازی، زمینه را برای ظهور نسل جدیدی از راهبردهای کنترل غیرخطی فراهم کرد.

\subsection{ظهور راهبردهای کنترل غیرخطی و مقاوم}
در حالی که کنترل‌کننده‌های خطی مانند \lr{PID} و $LQR$ در پایدارسازی کوادروتور حول نقطه شناوری موفق بودند، عملکرد آن‌ها در مانورهای تهاجمی و در حضور اغتشاشات شدید به شدت افت می‌کرد. این "شکنندگی" در دنیای واقعی، پژوهشگران را ناچار کرد تا از فرض خطی‌سازی فاصله گرفته و به سراغ روش‌هایی بروند که مستقیماً با ذات غیرخطی سیستم روبرو شوند. این نیاز، سرآغاز دوره کنترل غیرخطی مقاوم بود.

\subsection*{خطی‌سازی فیدبک}
روش خطی‌سازی فیدبک\LTRfootnote{Feedback Linearization} یک رویکرد ظریف برای رام کردن دینامیک غیرخطی است. ایده اصلی این است که با استفاده از یک فیدبک حالت غیرخطی و یک تبدیل مختصات، دینامیک غیرخطی اصلی به یک سیستم خطی معادل و ساده (معمولاً مجموعه‌ای از انتگرال‌گیرهای دوگانه) تبدیل شود \cite{mian2021review, sabatino2015modeling, maaruf2022survey}. پس از این تبدیل، می‌توان از ابزارهای کنترل خطی استاندارد برای کنترل سیستم در کل پوش پروازی استفاده کرد. این روش، برخلاف \lr{PID} و \lr{LQR}، به یک نقطه کار محدود نیست. با این حال، نقطه ضعف اصلی \lr{FBL} در حساسیت شدید آن به دقت مدل ریاضی نهفته است. این روش بر "حذف کامل" جملات غیرخطی استوار است و هرگونه خطای مدل‌سازی یا عدم قطعیت پارامتری می‌تواند این حذف را ناقص کرده و منجر به عملکرد ضعیف یا حتی ناپایداری شود \cite{islam2023robust, guerrero2020feedback, omar2022recent}.


\subsection*{کنترل پس‌گام}
کنترل پس‌گام\LTRfootnote{Backstepping Control} یک روش طراحی بازگشتی و سیستماتیک است که بر پایه تئوری پایداری لیاپانوف\LTRfootnote{Lyapunov stability theory} بنا شده است \cite{mian2021review, maaruf2022survey}. این روش برای سیستم‌های غیرخطی که ساختار آبشاری\LTRfootnote{Cascaded structure} دارند، بسیار مناسب است. با توجه به اینکه دینامیک کوادروتور را می‌توان به یک زیرسیستم دورانی (حلقه داخلی) و یک زیرسیستم انتقالی (حلقه خارجی) تقسیم کرد، \lr{BSC} به یک انتخاب طبیعی تبدیل شد. مقاله بنیادین \lr{Madani, Benallegue (2006)} یکی از اولین و تأثیرگذارترین کاربردهای \lr{BSC} برای کوادروتور را ارائه داد. آن‌ها با تجزیه سیستم به زیرسیستم‌های کمتر-عملگر و کاملاً عملگر، یک کنترل‌کننده پس‌گام طراحی کردند که پایداری کل سیستم را تضمین می‌کرد \cite{madani2006backstepping}.
با وجود قدرت تئوری، \lr{BSC} در عمل با چالش "انفجار پیچیدگی"\LTRfootnote{Explosion of complexity} مواجه است \cite{dierks2009backstepping}. در هر مرحله از فرآیند بازگشتی، از مشتق قوانین کنترل مجازی\LTRfootnote{Virtual control laws} مراحل قبل استفاده می‌شود که این امر منجر به ایجاد عبارات ریاضی بسیار طولانی و پیچیده برای قانون کنترل نهایی می‌گردد. این پیچیدگی، پیاده‌سازی عملی و تنظیم کنترل‌کننده را دشوار می‌سازد. همچنین، این روش می‌تواند به مشکل "پارامتردهی بیش از حد"\LTRfootnote{Over-parameterization} دچار شود \cite{mian2021review_2}.


\subsection*{کنترل مد لغزشی}

کنترل مد لغزشی\LTRfootnote{Sliding Mode Control} یک تکنیک کنترل مقاوم بسیار قدرتمند است که فلسفه متفاوتی را دنبال می‌کند. به جای تلاش برای حذف دقیق غیرخطی‌ها، \lr{SMC} یک "سطح لغزش"\LTRfootnote{Sliding surface} را در فضای حالت تعریف می‌کند که نشان‌دهنده دینامیک خطای مطلوب است. سپس یک قانون کنترل سوئیچینگ (غیرپیوسته) طراحی می‌شود تا حالت‌های سیستم را در زمان محدود به این سطح برساند و آن‌ها را روی سطح نگه دارد \cite{zhang2023control, maaruf2022survey}. هنگامی که سیستم روی سطح لغزش قرار دارد، رفتار آن دقیقاً مطابق با دینامیک مطلوب تعریف‌شده توسط سطح است و مهم‌تر از آن، نسبت به دسته‌ای از اغتشاشات و عدم قطعیت‌های مدل که به آن‌ها "عدم قطعیت‌های تطبیق‌یافته"\LTRfootnote{Matched uncertainties} گفته می‌شود، کاملاً مقاوم است \cite{lone2025improved}.
مطالعات تطبیقی متعدد، مانند آنچه در \cite{ghadiok2023historical} و \cite{islam2023robust} گزارش شده، برتری \lr{SMC} را از نظر دقت ردیابی و مقاومت در برابر اغتشاشات نسبت به \lr{PID} و \lr{FBL} تأیید کرده‌اند. با این حال، بزرگترین عیب \lr{SMC}، پدیده چترینگ\LTRfootnote{Chattering} است \cite{chen2025super, islam2023robust, benallegue2008sliding}. ماهیت سوئیچینگ با فرکانس بالای قانون کنترل در نزدیکی سطح لغزش، باعث ایجاد ارتعاشات با فرکانس بالا در سیگنال کنترل می‌شود. این پدیده نه تنها باعث اتلاف انرژی می‌شود، بلکه می‌تواند دینامیک‌های مدل‌سازی‌نشده فرکانس بالا را تحریک کرده و به عملگرهای فیزیکی (موتورها) آسیب برساند. این مشکل عملی، انگیزه‌ای قوی برای توسعه نسخه‌های بهبودیافته \lr{SMC} مانند کنترل مد لغزشی مرتبه بالا\LTRfootnote{Higher-Order SMC} و الگوریتم \lr{Super-Twisting} شد که هدف آن‌ها کاهش یا حذف چترینگ ضمن حفظ مقاومت سیستم است \cite{chen2025super}.

\subsection{رویکردهای پیشرفته برای مقابله با عدم قطعیت}
وابستگی بنیادین کنترل‌کننده‌های مبتنی بر مدل (حتی انواع غیرخطی آن) به یک مدل ریاضی دقیق، بزرگترین نقطه ضعف آن‌ها در کاربردهای دنیای واقعی است. دوره مدرن طراحی کنترل‌کننده برای کوادروتور با ظهور تکنیک‌هایی مشخص می‌شود که به جای نادیده گرفتن یا سرکوب کردن عدم قطعیت، به طور فعال آن را تخمین زده و خود را با آن تطبیق می‌دهند. این رویکردها نشان‌دهنده یک تغییر پارادایم از کنترل "صلب" به کنترل "هوشمند" و "آگاه از محیط" است.
در این میان، یک انشعاب فلسفی در نحوه دستیابی به مقاومت پدیدار می‌شود. یک مسیر، که توسط کنترل‌کننده‌هایی مانند \lr{SMC} نمایندگی می‌شود، تلاش می‌کند تا با استفاده از بهره‌های بالا و قوانین کنترل قدرتمند، بر عدم قطعیت "غلبه" کند \cite{ benallegue2008sliding}. مسیر دیگر، که توسط کنترل تطبیقی و رویکردهای مبتنی بر رؤیتگر نمایندگی می‌شود، به دنبال "تخمین و حذف" عدم قطعیت است \cite{islam2015robust, benevides2022disturbance}. یک مسیر سوم و جدیدتر نیز که توسط روش‌های یادگیری تقویتی ارائه شده، به طور کلی مدل خاص را "نادیده" می‌گیرد و سیاستی را می‌آموزد که ذاتاً در طیفی از مدل‌ها مقاوم باشد \cite{vaidya2023dynamics}.

\subsection*{کنترل تطبیقی}
کنترل تطبیقی\LTRfootnote{Adaptive Control} به طور خاص برای مقابله با عدم قطعیت‌های پارامتری طراحی شده است. این روش، پارامترهای کنترل‌کننده را به صورت آنلاین و در حین پرواز تنظیم می‌کند تا تغییرات در دینامیک سیستم، مانند تغییر جرم به دلیل حمل بار، را جبران نماید \cite{mahfouz2022adaptive, islam2015robust}. یکی از محبوب‌ترین ساختارها، کنترل تطبیقی مدل مرجع \lr{(MRAC)}\LTRfootnote{Model Reference Adaptive Control} است. در این روش، یک مدل مرجع ایده‌آل و پایدار تعریف می‌شود و کنترل‌کننده تطبیقی وظیفه دارد پارامترهای خود را به گونه‌ای تنظیم کند که رفتار سیستم واقعی، رفتار مدل مرجع را دنبال کند \cite{dydek2013adaptive, mahfouz2025robust}. کارهایی مانند پژوهش \lr{Islam et al. (2015)} یک طراحی مقاوم تطبیقی را ارائه می‌دهند که جملات \lr{PD} کلاسیک را با قوانین تطبیقی مبتنی بر پایداری لیاپانوف ترکیب می‌کند \cite{islam2015robust}. مزیت بزرگ این روش‌ها این است که نیازی به دانستن کران بالای عدم قطعیت‌ها از قبل ندارند \cite{mahfouz2022adaptive}. با این حال، طراحی و اثبات پایداری آن‌ها می‌تواند پیچیده باشد و عملکردشان ممکن است به نویز اندازه‌گیری و دینامیک‌های مدل‌سازی‌نشده حساس باشد \cite{dydek2013adaptive, islam2023adaptive}.


\subsection*{کنترل مبتنی بر رؤیتگر اغتشاش}
کنترل مبتنی بر رؤیتگر اغتشاش\LTRfootnote{Disturbance Observer-Based Control} یک راهبرد عملی و مؤثر برای افزایش مقاومت یک کنترل‌کننده اسمی (مانند \lr{PID} یا \lr{LQR}) است. ایده اصلی این است که یک رؤیتگر\LTRfootnote{Observer} طراحی شود تا مجموع اغتشاشات خارجی و عدم قطعیت‌های مدل را به صورت یک "اغتشاش کلی" در زمان واقعی تخمین بزند. سپس این اغتشاش تخمین‌زده‌شده از طریق یک حلقه پیشخور\LTRfootnote{Feedforward loop} در قانون کنترل حذف می‌شود \cite{castillo2015robust, benevides2022disturbance, chen2022trajectory}. مطالعه \lr{Benevides et al. (2022)} یک نمونه برجسته از این رویکرد است که در آن از یک فیلتر کالمن\LTRfootnote{Kalman Filter} برای تخمین تندبادها استفاده شده و نتایج نشان‌دهنده بهبود چشمگیر در دقت ردیابی مسیر در حضور باد است \cite{benevides2022disturbance}. عملکرد \lr{DOBC} به دقت رؤیتگر و محدودیت‌های پهنای باند سیستم بستگی دارد، اما این روش یک راه حل ماژولار و کارآمد برای مقاوم‌سازی کنترل‌کننده‌های موجود ارائه می‌دهد.


\subsection*{کنترل مبتنی بر یادگیری}
یادگیری تقویتی عمیق\LTRfootnote{Deep Reinforcement Learning} یک تغییر پارادایم کامل از طراحی مبتنی بر مدل به طراحی مبتنی بر داده است. در این رویکرد، یک عامل\LTRfootnote{Agent} (کنترل‌کننده) به جای پیروی از معادلات از پیش تعیین‌شده، یاد می‌گیرد که چگونه با تعامل با محیط (که می‌تواند یک شبیه‌ساز فیزیکی دقیق باشد) و دریافت سیگنال پاداش، یک سیاست کنترلی بهینه را کشف کند \cite{vaidya2023dynamics, sonmez2025reinforcement}. پژوهش پیشگامانه \lr{Vaidya و Keshavan} یک کنترل‌کننده \lr{DRL} را معرفی می‌کند که با آموزش بر روی طیف وسیعی از دینامیک‌های شبیه‌سازی‌شده (با تغییر جرم و اینرسی)، به یک سیاست کنترلی "نامتغیر نسبت به دینامیک"\LTRfootnote{Dynamics-invariant} دست می‌یابد. نتایج آن‌ها بهبود دقت ردیابی تا 85درصد را نسبت به روش‌های پایه نشان می‌دهد \cite{vaidya2023dynamics, vaidya2023dynamics_2}.
با وجود پتانسیل بسیار بالا، روش‌های \lr{DRL} با چالش‌های جدی روبرو هستند. مهم‌ترین چالش، "شکاف شبیه‌سازی به واقعیت"\LTRfootnote{Sim-to-real gap} است؛ سیاستی که در شبیه‌سازی عملکرد عالی دارد، ممکن است در دنیای واقعی به دلیل تفاوت‌های جزئی در دینامیک و نویز سنسورها، عملکرد ضعیفی داشته باشد یا حتی ناپایدار شود \cite{vaidya2023dynamics, vaidya2023dynamics_2}. علاوه بر این، این روش‌ها به حجم عظیمی از داده‌های آموزشی نیاز دارند و فاقد تضمین‌های پایداری رسمی هستند، که این امر یک مانع بزرگ برای استفاده از آن‌ها در کاربردهای ایمنی-بحرانی\LTRfootnote{Safety-critical applications} محسوب می‌شود \cite{song2021can, vaidya2023dynamics}.

\newpage
\section{تحلیل تطبیقی، مباحثات جاری، و راهبردهای ترکیبی}
انتخاب یک استراتژی کنترلی برای کوادروتور، فرآیندی پیچیده است که مستلزم درک عمیق مصالحه‌های موجود بین عملکرد، مقاومت و پیچیدگی است. هیچ کنترل‌کننده واحدی وجود ندارد که در تمام معیارها برتر باشد. این بخش به تحلیل تطبیقی این راهبردها، بررسی مباحثات کلیدی در این حوزه، و معرفی روند غالب به سمت معماری‌های ترکیبی می‌پردازد.


\subsection{ارزیابی عملکرد و مصالحه}
کنترل‌کننده‌های خطی مانند \lr{PID} و \lr{LQR} از نظر پیاده‌سازی ساده و از نظر محاسباتی کم‌هزینه هستند، اما مقاومت و عملکرد آن‌ها در شرایط پروازی تهاجمی محدود است \cite{dallagi2023comparative, zulu2024review}. در مقابل، کنترل‌کننده‌های غیرخطی مانند \lr{SMC} و \lr{Backstepping} مقاومت بالایی ارائه می‌دهند اما با هزینه پیچیدگی طراحی و چالش‌هایی مانند چترینگ و انفجار پیچیدگی همراه هستند \cite{ghadiok2023historical, dallagi2023comparative}. یک مطالعه تطبیقی در \cite{dallagi2023comparative_2} نتیجه‌گیری می‌کند که \lr{SMC} به دلیل دینامیک سریع و مقاومت بالا، امیدوارکننده‌ترین گزینه برای پایدارسازی وضعیت زاویه‌ای است. \lr{MPC} \LTRfootnote{Model Predictive Control} به دلیل توانایی در مدیریت بهینه قیود حالت و ورودی، عملکرد بسیار خوبی ارائه می‌دهد، اما هزینه محاسباتی بالای آن به طور سنتی یک مانع بزرگ برای پیاده‌سازی بر روی پردازنده‌های تعبیه‌شده\LTRfootnote{Embedded processors} بوده است \cite{zhang2022review, hanover2021l1}. روش‌های مبتنی بر یادگیری، پیچیدگی طراحی مبتنی بر مدل را با پیچیدگی جمع‌آوری داده و آموزش جایگزین می‌کنند و پتانسیل بالاترین عملکرد را دارند، اما با عدم قطعیت در ایمنی همراه هستند \cite{vaidya2023dynamics, song2021can}.
جالب توجه است که مفهوم "پیچیدگی محاسباتی" یک هدف متحرک است. آنچه در گذشته غیرقابل اجرا تلقی می‌شد، مانند \lr{MPC}، امروزه با پیشرفت پردانتخاب کنترل‌کننده مناسب برای یک کاربرد خاص، بیش از آنکه به دنبال یافتن "بهترین" کنترل‌کننده باشد، به یافتن "مناسب‌ترین" آن با توجه به محدودیت‌ها و الزامات پروژه مربوط می‌شود. مطالعات تطبیقی متعدد، مانند آنچه در \cite{zulu2024review}, \cite{zulu2014review} و \cite{dallagi2023comparative} ارائه شده، به روشن شدن این مصالحه‌ها کمک کرده‌اند.

با پیشرفت پردازنده‌های تعبیه‌شده، الگوریتم‌های کنترلی به صورت بلادرنگ\LTRfootnote{Real-time} قابل پیاده‌سازی شدند \cite{foehn2018state, hanover2021l1}. این تحول، کانون مصالحه را از "آیا می‌توانیم آن را اجرا کنیم؟" به "آیا مدل‌سازی و تنظیم آن ارزش تلاش را دارد؟" تغییر داده است. این تغییر به نفع روش‌های مبتنی بر یادگیری است که مدل‌سازی پیچیده را با آموزش فشرده (اما آفلاین) جایگزین می‌کنند.


\subsection{مباحثات جاری: کنترل مبتنی بر مدل در مقابل کنترل مبتنی بر داده}
مبحثی که امروزه بیش از هر موضوع دیگری در حوزه کنترل کوادروتور جریان دارد، تقابل بین رویکرد سنتی مبتنی بر مدل\LTRfootnote{Model-based} و پارادایم نوظهور مبتنی بر داده\LTRfootnote{Data-driven} است. رویکرد مبتنی بر مدل، که شامل تمام کنترل‌کننده‌های کلاسیک و غیرخطی مورد بحث است، بر یک مدل ریاضی دقیق از سیستم تکیه دارد و عملکرد آن به طور مستقیم به وفاداری\LTRfootnote{Fidelity} این مدل به واقعیت وابسته است \cite{pounds2012detailed}. در مقابل، رویکرد مبتنی بر داده، به ویژه یادگیری تقویتی، می‌تواند بدون نیاز به یک مدل صریح، کنترل سیستم را بیاموزد \cite{vaidya2023dynamics, mahfouz2025robust}.
برخی مطالعات اولیه ادعا کرده‌اند که \lr{RL} به طور قابل توجهی از روش‌های سنتی بهتر عمل می‌کند \cite{vaidya2023dynamics_2}. با این حال، یک مطالعه انتقادی توسط \lr{Song et al.} \cite{song2021can} استدلال می‌کند که بسیاری از این مقایسه‌ها منصفانه نیستند. زمانی که یک کنترل‌کننده هندسی\LTRfootnote{Geometric controller} (یک روش پیشرفته مبتنی بر مدل) به طور بهینه تنظیم شود، شکاف عملکرد بین آن و \lr{RL} بسیار کمتر از آن چیزی است که قبلاً گزارش شده بود. یافته‌های آن‌ها نشان می‌دهد که \lr{RL} در عملکرد گذرا\LTRfootnote{Transient performance} برتری دارد، در حالی که کنترل هندسی خطای حالت ماندگار کمتری را به دست می‌آورد \cite{song2021can}.
این مبحث صرفاً یک بحث آکادمیک در مورد عملکرد نیست، بلکه پیامدهای عمیقی برای اعتماد و صدور گواهینامه\LTRfootnote{Trust and certification} دارد. کنترل‌کننده‌های مبتنی بر مدل دارای اثبات‌های پایداری ریاضی (مانند تئوری لیاپانوف) هستند که رفتار آن‌ها را قابل پیش‌بینی و تحلیل‌پذیر می‌سازد \cite{islam2015robust, madani2006backstepping, li2022second}. این ویژگی برای صدور گواهینامه در حوزه‌های ایمنی-بحرانی مانند هوانوردی ضروری است. در مقابل، کنترل‌کننده‌های \lr{DRL} اغلب به عنوان "جعبه سیاه"\LTRfootnote{Black box} عمل می‌کنند \cite{song2021can}. اگرچه عملکرد آن‌ها می‌تواند چشمگیر باشد، اثبات اینکه در یک حالت دیده‌نشده با شکست مواجه نخواهند شد، یک مسئله پژوهشی باز و دشوار است. این مانع عملی، مسیر آینده را به سمت پژوهش در زمینه هوش مصنوعی قابل تأیید\LTRfootnote{Certifiable AI} و یادگیری تقویتی ایمن\LTRfootnote{Safe RL}، یا روش‌های ترکیبی که در آن یک کنترل‌کننده پشتیبان با پایداری اثبات‌شده بر عملکرد یک کنترل‌کننده مبتنی بر یادگیری نظارت می‌کند، هدایت می‌کند.


\subsection{روند غالب: معماری‌های کنترل ترکیبی}
با توجه به اینکه هیچ راهبرد کنترلی "خالص" واحدی وجود ندارد که بتواند به تمام چالش‌های کنترل کوادروتور پاسخ دهد، یک روند غالب در این حوزه، حرکت به سمت معماری‌های کنترل ترکیبی\LTRfootnote{Hybrid Control Architectures} است. این رویکردها با ترکیب هوشمندانه نقاط قوت چندین استراتژی، به دنبال غلبه بر ضعف‌های فردی آن‌ها هستند \cite{mian2021review, zhang2022review, mian2021review_2}. بلوغ این حوزه را می‌توان در کثرت و تنوع طرح‌های ترکیبی مشاهده کرد که نشان‌دهنده یک اجماع در میان پژوهشگران است: آینده کنترل مقاوم و با عملکرد بالا در این ترکیبات هوشمندانه نهفته است.

نمونه‌هایی از این معماری‌های ترکیبی عبارتند از:

ترکیب کنترل خطی و هوشمند: مانند \lr{Fuzzy PID} که در آن از منطق فازی برای تنظیم آنلاین بهره‌های کنترل‌کننده \lr{PID} استفاده می‌شود تا سازگاری آن با شرایط متغیر بهبود یابد. یا استفاده از \lr{RL} برای پیش‌بینی و تنظیم بهره‌های \lr{PID} در حین پرواز \cite{sonmez2025reinforcement}.

ترکیب کنترل‌کننده‌های غیرخطی: مانند ترکیب \lr{Backstepping} و \lr{SMC} که در آن ساختار سیستماتیک \lr{Backstepping} با مقاومت \lr{SMC} ادغام می‌شود \cite{islam2023robust}. اخیراً، کنترل‌کننده‌های ترکیبی الهام گرفته از طبیعت\LTRfootnote{Bio-inspired} که این دو روش را برای حذف همزمان پرش سرعت و چترینگ به کار می‌گیرند، مورد توجه قرار گرفته‌اند \cite{li2025novel}.

ترکیب کنترل بهینه و مقاوم: مانند ترکیب \lr{MPC} با \lr{H-infinity} که در آن کنترل‌کننده \lr{H-infinity} برای پایدارسازی اولیه و کاهش بار محاسباتی \lr{MPC} استفاده می‌شود \cite{zhang2024robust}.

ترکیب کنترل تطبیقی و مقاوم: مانند \lr{Adaptive Backstepping SMC} که در آن قوانین تطبیقی برای تخمین عدم قطعیت‌ها به کار می‌روند و \lr{SMC} مقاومت در برابر اغتشاشات باقی‌مانده را تضمین می‌کند \cite{mian2021review_2}.

این روند به وضوح نشان می‌دهد که میدان تحقیق از جستجو برای یک "گلوله نقره‌ای" عبور کرده و به سمت طراحی سیستم‌های کنترلی یکپارچه و چندلایه حرکت کرده است که هر لایه برای مقابله با جنبه خاصی از چالش کنترل کوادروتور بهینه شده است.




%-------------------- 
\begin{table}[H] 
    \centering % To center the table on the page
    \caption{مقایسه راهبردهای کنترل کلیدی برای کوادروتور}
    \label{tab:strategy_comparison_onepage}
    \renewcommand{\arraystretch}{1.5} % Adjust row height for readability
    
    \begin{tabular}{
        >{\raggedright\arraybackslash}p{2.5cm} % راهبرد کنترل
        >{\raggedright\arraybackslash}p{4cm}  % اصل بنیادی
        >{\raggedright\arraybackslash}p{4.5cm} % نقاط قوت
        >{\raggedright\arraybackslash}p{4.5cm} % ضعف‌ها
    }
        \toprule
        \textbf{راهبرد کنترل} & 
        \textbf{اصل بنیادی} & 
        \textbf{نقاط قوت کلیدی} & 
        \textbf{ضعف‌ها و چالش‌های اصلی} \\
        \midrule

        \lr{\textbf{PID}} &
        فیدبک مبتنی بر خطا &
        سادگی، پیچیدگی کم، تنظیم بدون نیاز به مدل &
        عملکرد ضعیف برای سیستم‌های شدیداً غیرخطی، تنظیم دستی \\
        \midrule

        \lr{\textbf{LQR}} &
        کنترل بهینه از طریق کمینه‌سازی تابع هزینه &
        بهینه برای سیستم‌های خطی، مدیریت \lr{MIMO} &
        نیاز به خطی‌سازی، احتمال خطای حالت ماندگار \\
        \midrule

        \lr{\textbf{Backstepping}} &
        طراحی بازگشتی مبتنی بر لیاپانوف &
        سیستماتیک برای سیستم‌های غیرخطی، تضمین پایداری &
        "انفجار پیچیدگی"، پارامتردهی بیش از حد \\
        \midrule

        \lr{\textbf{SMC}} &
        وادار کردن حالت به یک سطح لغزش &
        مقاومت بالا در برابر اغتشاشات و عدم قطعیت‌ها &
        پدیده چترینگ، نیاز به دانستن کران اغتشاشات \\
        \midrule

        \lr{\textbf{MPC}} &
        بهینه‌سازی آنلاین روی یک افق پیش‌بینی &
        مدیریت قیود، قابلیت پیش‌بینی &
        هزینه محاسباتی بالا، وابسته به مدل \\
        \midrule

        \textbf{کنترل تطبیقی} &
        تنظیم آنلاین پارامترها &
        جبران عدم قطعیت‌های پارامتری (مانند بار) &
        تحلیل پایداری پیچیده، حساسیت به نویز \\
        \midrule

        \textbf{یادگیری تقویتی} &
        بهینه‌سازی سیاست بدون مدل از طریق پاداش &
        مقاومت در برابر دینامیک‌های مدل‌نشده، یادگیری سیاست‌های بهینه &
        شکاف شبیه‌سازی به واقعیت، نیاز به داده زیاد، نگرانی‌های ایمنی \\
        \bottomrule
    \end{tabular}
\end{table}
%-------------------- 
جدول \ref{tab:strategy_comparison_onepage} یک نمای کلی و مقایسه‌ای از راهبردهای کنترل کلیدی برای کوادروتورها ارائه می‌دهد که در بخش مرور ادبیات به تفصیل مورد بحث قرار گرفتند. این جدول هر روش کنترلی از \lr{PID} و $LQR$ کلاسیک گرفته تا روش‌های پیشرفته‌تر مانند $SMC$، کنترل تطبیقی و یادگیری تقویتی را بر اساس چهار معیار اساسی ارزیابی می‌کند: 

اصل بنیادی عملکرد، نقاط قوت کلیدی، و ضعف‌ها و چالش‌های اصلی آن. هدف از این مقایسه، نمایش تصویری مصالحه‌ها بین عملکرد، پیچیدگی و مقاومت است؛ برای مثال، تقابل بین سادگی \lr{PID} و مقاومت بالای $SMC$ در برابر اغتشاشات، یا پتانسیل بالای یادگیری تقویتی در مقابل نگرانی‌های مربوط به ایمنی آن. این جمع‌بندی به خواننده کمک می‌کند تا به سرعت درک کند که چرا هیچ کنترل‌کننده واحدی برای تمام کاربردها ایده‌آل نیست و انتخاب نهایی به الزامات خاص پروژه بستگی دارد.

\newpage
\section{شکاف‌های پژوهشی و چشم‌اندازهای آینده}
علی‌رغم پیشرفت‌های چشمگیر در زمینه کنترل کوادروتور، هنوز شکاف‌های قابل توجهی در ادبیات علمی وجود دارد و مسیرهای پژوهشی متعددی برای آینده باز است. شناسایی این شکاف‌ها نه تنها برای توجیه پژوهش‌های جدید ضروری است، بلکه نقشه راهی برای پیشرفت این حوزه در سال‌های آینده فراهم می‌کند.
\subsection{شکاف‌های شناسایی‌شده در پژوهش‌های پیشین}
ارزیابی انتقادی مجموعه کارهای انجام‌شده، چندین محدودیت و شکاف کلیدی را آشکار می‌سازد:

شکاف ۱: فقدان محک‌زنی استاندارد و تکرارپذیری: یکی از بزرگترین موانع در پیشرفت این حوزه، دشواری در مقایسه منصفانه نتایج مطالعات مختلف است. بسیاری از مقالات، نتایج خود را با استفاده از سخت‌افزارها، شرایط آزمایشی، و معیارهای ارزیابی متفاوتی گزارش می‌دهند \cite{ghadiok2023historical, omar2022recent}. پارامترهای کلیدی مانند جرم کوادروتور، بهره‌های کنترل‌کننده، سرعت باد، و مشخصات مسیر اغلب حذف می‌شوند که این امر تکرارپذیری\LTRfootnote{Reproducibility} نتایج را تقریباً غیرممکن می‌سازد. همانطور که در \cite{ghadiok2023historical} و \cite{omar2022recent} به درستی اشاره شده، نیاز مبرمی به استانداردهایی برای گزارش‌دهی (مانند ارائه همزمان خطای جذر میانگین مربعات \lr{(RMSE)}\LTRfootnote{Root Mean Square Error} و حداکثر خطای ردیابی \lr{(MTE)}\LTRfootnote{Maximum Tracking Error} و همچنین برای کمی‌سازی اغتشاشات (مثلاً بیان نیروی باد به صورت نسبتی از وزن وسیله نقلیه) وجود دارد. مطالعه \cite{song2021can} نیز نشان می‌دهد که چگونه مقایسه‌های غیراستاندارد می‌تواند به نتایج گمراه‌کننده در مورد برتری یک کلاس از کنترل‌کننده‌ها بر دیگری منجر شود.

شکاف ۲: مقاومت در سناریوهای تهاجمی و بدون ساختار: در حالی که بسیاری از کنترل‌کننده‌ها مقاومت خوبی در برابر اغتشاشات متوسط از خود نشان می‌دهند، پژوهش‌های کمی در مورد کنترل برای مانورهای بسیار تهاجمی در محیط‌های شلوغ و ناشناخته، مانند پرواز از میان شکاف‌های باریک، انجام شده است \cite{falanga2017aggressive, tranzhao2022whole}. این سناریوها چالش "بینایی فعال"\LTRfootnote{Active vision} را مطرح می‌کنند که در آن کنترل و ادراک به شدت به یکدیگر وابسته هستند؛ کوادروتور باید وضعیت خود را به گونه‌ای کنترل کند که شکاف همیشه در میدان دید سنسورهایش باقی بماند \cite{falanga2017aggressive}. به طور مشابه، کنترل کوادروتورها هنگام حمل بارهای معلق بزرگ و دینامیک (مانند بارهای آویزان) یک چالش بزرگ باقی مانده است و حوزه‌هایی مانند برخاست و فرود در این شرایط به طور خاص کمتر مورد مطالعه قرار گرفته‌اند \cite{omar2022recent}.

شکاف ۳: شکاف شبیه‌سازی به واقعیت برای کنترل مبتنی بر یادگیری: یک مانع اساسی برای استقرار عملی روش‌های مبتنی بر یادگیری، به ویژه \lr{DRL}، انتقال سیاست‌های آموخته‌شده در شبیه‌سازی به دنیای واقعی بدون افت قابل توجه عملکرد است \cite{vaidya2023dynamics, vaidya2023dynamics_2}. اگرچه تلاش‌هایی برای کاهش این شکاف از طریق تکنیک‌هایی مانند تصادفی‌سازی دینامیک\LTRfootnote{Dynamics Randomization} و استفاده از داده‌های واقعی در فرآیند آموزش صورت گرفته است \cite{vaidya2023dynamics}، این مسئله همچنان یک چالش بنیادی برای این حوزه باقی مانده است.

شکاف ۴: ایمنی، تأیید و صدور گواهینامه: برای کنترل‌کننده‌های مبتنی بر یادگیری و الگوریتم‌های تطبیقی بسیار پیچیده، یک شکاف عمیق در زمینه روش‌های صوری\LTRfootnote{Formal methods} برای تأیید پایداری و تضمین عملکرد ایمن وجود دارد. این شکاف، بزرگترین مانع برای استقرار این فناوری‌های قدرتمند در کاربردهای دنیای واقعی و ایمنی-بحرانی است \cite{song2021can}.
این شکاف‌های پژوهشی به طور عمیقی به یکدیگر مرتبط هستند. به عنوان مثال، حل مسئله پرواز تهاجمی در محیط‌های شلوغ (شکاف ۲) نیازمند ادراک بهتر است. ادراک بهتر به سنسورها متکی است که نویز را به سیستم وارد می‌کنند. مدیریت نویز سنسور و سایر اثرات دنیای واقعی، مشکل شکاف شبیه‌سازی به واقعیت (شکاف ۳) را برای کنترل‌کننده‌های مبتنی بر یادگیری تشدید می‌کند. استفاده از یک کنترل‌کننده مبتنی بر یادگیری برای چنین وظیفه ایمنی-بحرانی، بلافاصله مسئله تأیید و صدور گواهینامه (شکاف ۴) را مطرح می‌کند. این درهم‌تنیدگی نشان می‌دهد که تأثیرگذارترین پژوهش‌های آینده، پژوهش‌هایی خواهند بود که به صورت کل‌نگر و یکپارچه به مسائل کنترل، ادراک و ایمنی بپردازند.

\subsection{مسیرهای تحقیقاتی آینده}
مسیرهای پژوهشی آینده مستقیماً از شکاف‌های شناسایی‌شده نشأت می‌گیرند و به دنبال ارائه راه‌حل‌هایی برای چالش‌های باقی‌مانده هستند:

مسیر ۱: توسعه کنترل‌کننده‌های تطبیقی و مبتنی بر یادگیری قابل تأیید: پژوهش‌های آینده باید بر روی معماری‌های ترکیبی تمرکز کنند که یک کنترل‌کننده مبتنی بر یادگیری با عملکرد بالا را با یک لایه نظارتی ایمنی-بحرانی مبتنی بر روش‌های با پایداری اثبات‌شده (مانند \lr{SMC} یا \lr{LQR}) ترکیب می‌کنند. این رویکرد مستقیماً به شکاف ایمنی و تأیید (شکاف ۴) پاسخ می‌دهد.

مسیر ۲: کنترل و ادراک یکپارچه برای ناوبری چابک: کارهای آینده باید بر روی ادغام تنگاتنگ الگوریتم‌های ادراک پیشرفته (به ویژه مبتنی بر بینایی ماشین) با کنترل‌کننده‌های مقاوم تمرکز کنند. این امر، ناوبری خودران در محیط‌های ناشناخته و پویا را امکان‌پذیر می‌سازد و به چالش مقاومت در سناریوهای بدون ساختار (شکاف ۲) و مسئله "بینایی فعال" مطرح‌شده در \cite{falanga2017aggressive} می‌پردازد.

مسیر ۳: یادگیری ماشین آگاه از فیزیک: برای پر کردن شکاف شبیه‌سازی به واقعیت (شکاف ۳)، پژوهش‌ها باید به سمت روش‌هایی حرکت کنند که اصول فیزیکی شناخته‌شده (مانند معادلات دینامیکی 6-$DOF$) را در فرآیند یادگیری ادغام می‌کنند. این رویکرد که به آن یادگیری ماشین آگاه از فیزیک\LTRfootnote{Physics-Informed Machine Learning} گفته می‌شود، می‌تواند کارایی نمونه‌برداری\LTRfootnote{Sample efficiency} را بهبود بخشد و به سیاست‌های تعمیم‌پذیرتر\LTRfootnote{Generalizable policies} منجر شود.

مسیر ۴: کنترل مقاوم برای تعامل فیزیکی و دستکاری: گسترش دامنه کاربرد کوادروتورها از پرواز صرف به وظایفی که شامل تماس فیزیکی هستند، مانند دستکاری هوایی با بازوهای رباتیک \cite{leeNDdynamics}، نیازمند نسل جدیدی از کنترل‌کننده‌ها است. این کنترل‌کننده‌ها باید بتوانند نیروهای تماسی و تغییرات شدید دینامیک سیستم ناشی از تعامل با محیط را مدیریت کنند.

در نهایت، آینده کنترل کوادروتور تنها در طراحی یک الگوریتم بهتر خلاصه نمی‌شود، بلکه در طراحی یک اکوسیستم توسعه و اعتبارسنجی بهتر نهفته است. درخواست برای محک‌زنی استاندارد و تکرارپذیری (شکاف ۱)
\cite{ghadiok2023historical, omar2022recent}، در واقع فراخوانی برای یک متدولوژی پژوهشی جدید است. نیاز به انتقال بهتر از شبیه‌سازی به واقعیت (شکاف ۳)، به نیاز برای شبیه‌سازهای با وفاداری بالاتر و تکنیک‌های تصادفی‌سازی دامنه بهتر اشاره دارد. چالش ایمنی و صدور گواهینامه (شکاف ۴) نیز به نیاز برای ابزارها و چارچوب‌های تأیید جدید اشاره می‌کند. بنابراین، یک سهم بزرگ در آینده این حوزه ممکن است نه یک کنترل‌کننده جدید، بلکه یک مجموعه محک‌زنی عمومی، با وفاداری بالا و استاندارد باشد که امکان مقایسه عادلانه و تکرارپذیر همه راهبردهای کنترلی را فراهم آورد و پیشرفت در کل این حوزه را تسریع بخشد.

\newpage
\chapter{انتخاب کنترل کننده و شرح ویژگی‌ها}
\section{مدل دینامیکی غیرخطی}
اساس هر تحلیل کنترلی، درک صحیح از مدل ریاضی سیستم است. دینامیک یک کوادروتور با شش درجه آزادی، که شامل سه حرکت انتقالی در امتداد محورهای $x, y, z$ و سه حرکت دورانی حول این محورها ($\phi, \theta, \psi$) است، با استفاده از فرمالیسم نیوتن-اویلر توصیف می‌شود. این مدل، رابطه بین نیروهای ورودی کنترلی و شتاب‌های انتقالی و زاویه‌ای حاصل را بیان می‌کند. ورودی‌های کنترلی سیستم چهار عدد هستند:

نیروی تراست کلی ($U1$) که از مجموع نیروی تولیدی هر چهار موتور حاصل می‌شود و سه گشتاور دورانی ($U2, U3, U4$) که از اختلاف سرعت موتورها ایجاد می‌شوند.

معادلات حاکم بر دینامیک سیستم، ذاتاً غیرخطی هستند. این غیرخطی بودن به دلیل وجود جملات مثلثاتی زوایای اویلر (مانند 
$sin(\theta)$ و $cos(\phi)$) و حاصل‌ضرب سرعت‌های زاویه‌ای در معادلات گشتاور است. این معادلات پیچیده، رفتار دینامیکی کوادروتور را توصیف می‌کنند و مبنای طراحی هر کنترل‌کننده‌ای قرار می‌گیرند.

\begin{align}
\ddot{x} &= (\cos \phi \sin \theta \cos \psi + \sin \phi \sin \psi) \frac{U_1}{m} \\
\ddot{y} &= (\cos \phi \sin \theta \sin \psi - \sin \phi \cos \psi) \frac{U_1}{m} \\
\ddot{z} &= -g + (\cos \phi \cos \theta) \frac{U_1}{m}
\end{align}

\begin{align}
\ddot{\phi} &= \dot{\theta} \dot{\psi} \frac{I_{yy} - I_{zz}}{I_{xx}} + \frac{U_2}{I_{xx}} \\
\ddot{\theta} &= \dot{\phi} \dot{\psi} \frac{I_{zz} - I_{xx}}{I_{yy}} + \frac{U_3}{I_{yy}} \\
\ddot{\psi} &= \dot{\phi} \dot{\theta} \frac{I_{xx} - I_{yy}}{I_{zz}} + \frac{U_4}{I_{zz}}
\end{align}

در این معادلات، $m$ جرم کوادروتور، $g$ شتاب گرانش و 
$I_{xx}$, $I_{yy}$, $I_{zz}$ ممان‌های اینرسی حول محورهای بدنه هستند. ارائه این مدل ریاضی پیچیده، اولین گام در درک این موضوع است که چرا یک کنترل‌کننده خطی ساده برای مدیریت چنین سیستمی کافی نیست و نیاز به رویکردهای پیشرفته‌تر احساس می‌شود.

\newpage
\section{تحلیل ویژگی‌های ذاتی سیستم}
دینامیک پیچیده کوادروتور دارای سه ویژگی ذاتی است که چالش‌های کنترلی اساسی را به وجود می‌آورند:

\textbf{کم‌تحریکی (\lr{Underactuation}):} کوادروتور یک نمونه کلاسیک از سیستم‌های کم‌تحریک است. این سیستم دارای شش درجه آزادی (سه موقعیت و سه زاویه) است که باید کنترل شوند، اما تنها چهار ورودی کنترلی مستقل (سرعت چهار موتور) در اختیار دارد. این عدم تطابق بین تعداد درجات آزادی و ورودی‌های کنترلی به این معناست که نمی‌توان تمام حالت‌های سیستم را به طور مستقیم و مستقل کنترل کرد.

\textbf{کوپل شدید (\lr{Strong Coupling}):} ماهیت کم‌تحریک سیستم مستقیماً منجر به کوپل شدید بین دینامیک دورانی و انتقالی می‌شود. به عنوان مثال، برای ایجاد شتاب در جهت افقی (مثلاً در امتداد محور $x$)، کوادروتور باید با ایجاد زاویه رول یا پیچ، بردار تراست کلی خود را کج کند تا مؤلفه‌ای از نیرو در آن جهت ایجاد شود. این بدان معناست که کنترل موقعیت و کنترل وضعیت (\lr{attitude}) به طور جدایی‌ناپذیری به هم مرتبط هستند. این ارتباط یک محدودیت بنیادی است که معماری کنترل را دیکته می‌کند و مهندسان را مجبور به استفاده از استراتژی‌های کنترل سلسله‌مراتبی یا آبشاری (\lr{cascaded}) می‌کند. در این معماری، یک حلقه کنترل بیرونی کندتر برای موقعیت، مقادیر مطلوب (\lr{setpoints}) را برای یک حلقه کنترل داخلی سریع‌تر برای وضعیت تولید می‌کند.

\textbf{ناپایداری ذاتی (\lr{Inherent Instability}):} کوادروتور در حلقه باز یک سیستم ذاتاً ناپایدار است. این سیستم، مشابه یک آونگ معکوس، برای حفظ پایداری خود نیازمند کنترل فیدبک فعال و مداوم است. حتی عمل ساده‌ای مانند پرواز ایستا (\lr{hovering}) نیز یک وظیفه کنترلی غیربدیهی است که نیازمند تنظیم مداوم سرعت موتورها برای مقابله با کوچک‌ترین انحرافات است.

وابستگی حیاتی دقت موقعیت به پایداری وضعیت، یک پیامد مهم دیگر دارد: عملکرد کل سیستم به طور نامتناسبی به مقاومت و دقت حلقه کنترل وضعیت داخلی وابسته است. یک خطای کوچک و گذرا در کنترل وضعیت، در طول زمان انتگرال‌گیری شده و به یک خطای بزرگ و بالقوه غیرقابل جبران در موقعیت تبدیل می‌شود. این موضوع اهمیت کنترل‌کننده‌هایی را که پایداری وضعیت سریع، مقاوم و دقیقی را فراهم می‌کنند، دوچندان می‌کند و توجیه‌کننده استفاده از کنترل‌کننده‌های بسیار پاسخگو مانند \lr{Fuzzy-PID} یا کنترل مد لغزشی ($SMC$) در حلقه داخلی است.

\newpage
\section{چالش‌های عملیاتی: اغتشاشات و عدم قطعیت‌ها}
علاوه بر پیچیدگی‌های ذاتی مدل، کوادروتورها در محیط‌های واقعی با مجموعه‌ای از چالش‌های عملیاتی مواجه هستند که کنترل‌کننده باید بر آن‌ها غلبه کند:

اغتشاشات خارجی: سیستم به شدت به اغتشاشات خارجی مانند تندبادها و تلاطم‌های جوی حساس است. این عوامل نیروها و گشتاورهای مدل‌سازی نشده‌ای را بر بدنه پرنده اعمال می‌کنند که می‌توانند به سرعت آن را از مسیر مطلوب منحرف کنند.

عدم قطعیت‌های داخلی و پارامتری: کنترل‌کننده با عدم قطعیت‌های متعددی از منابع داخلی نیز روبرو است که شامل موارد زیر می‌شود:

عدم دقت مدل: همواره تفاوت‌هایی بین مدل ریاضی و سیستم فیزیکی واقعی وجود دارد.

تغییرات بار: در کاربردهایی مانند پهپادهای سم‌پاش کشاورزی یا حمل محموله، تغییرات در جرم و مرکز ثقل سیستم، خواص اینرسی آن را تغییر می‌دهد و دینامیک پرواز را تحت تأثیر قرار می‌دهد.

خطاهای عملگر/حسگر: احتمال آسیب به موتورها، نوسانات ولتاژ یا نقص در عملکرد حسگرها می‌تواند رفتارهای غیرقابل پیش‌بینی را در سیستم ایجاد کرده و پایداری را به خطر اندازد.

در مجموع، دینامیک غیرخطی، کوپل شده، کم‌تحریک و ناپایدار کوادروتور، همراه با حساسیت آن به اغتشاشات و عدم قطعیت‌ها، یک مسئله کنترلی چالش‌برانگیز را ایجاد می‌کند که راه‌حل‌های کنترل خطی سنتی را به مرزهای کارایی خود می‌رساند و نیاز به یک رویکرد کنترل مقاوم و تطبیقی را به وضوح نشان می‌دهد.

\newpage
\section{کنترل کننده \lr{Fuzzy-PID}}
کوادروتور، یک وسیله نقلیه هوایی بدون سرنشین ($UAV$)، به عنوان یک پلتفرم رباتیک شش درجه آزادی ($6-DOF$) تعریف می‌شود. این شش درجه آزادی شامل سه حرکت انتقالی در امتداد محورهای مختصات دکارتی ($x, y, z$) و سه حرکت دورانی حول این محورها است که به ترتیب با نام‌های رول ($Roll$)، پیچ ($Pitch$) و یاو ($Yaw$) شناخته می‌شوند. در سال‌های اخیر، به دلیل سادگی ساختار مکانیکی، قابلیت برخاست و فرود عمودی ($VTOL$) و قدرت مانور بالا، کوادروتورها به یکی از محبوب‌ترین پلتفرم‌ها در تحقیقات دانشگاهی و کاربردهای صنعتی تبدیل شده‌اند. با این حال، این سادگی مکانیکی، یک چالش کنترلی پیچیده را پنهان می‌کند. کوادروتور ذاتاً یک سیستم ناپایدار، غیرخطی و کم-عملگر ($Underactuated$) است. این ویژگی‌ها به این معناست که بدون یک سیستم کنترل حلقه-بسته فعال و مقاوم، پرنده قادر به حفظ تعادل و پرواز پایدار نخواهد بود. بنابراین، طراحی یک کنترل‌کننده کارآمد که بتواند بر این ناپایداری‌ها غلبه کرده و پروازی دقیق و قابل اعتماد را تضمین کند، هسته اصلی مهندسی کنترل در این حوزه را تشکیل می‌دهد.

\subsection{ارزیابی انتقادی کنترل‌کننده \lr{PID}}
کنترل‌کننده تناسبی-انتگرالی-مشتقی ($Proportional-Integral-Derivative$) یا $PID$، به دلیل سادگی ساختاری و عملکرد قابل قبول در طیف وسیعی از سیستم‌ها، پرکاربردترین الگوریتم کنترل بازخوردی در صنعت است. قانون کنترل $PID$ به صورت ریاضی با معادله زیر تعریف می‌شود:
\begin{equation}u(t)=K_p\left(e(t)+\frac{1}{T_i}\int_0^te(\tau)d\tau+T_d\frac{d}{dt}e(t)\right)\end{equation}

در این معادله، $u(t)$ خروجی کنترل‌کننده، $e(t)$ سیگنال خطا (تفاوت بین مقدار مطلوب و مقدار واقعی)، و $Kp$​,$Ki$​,$Kd$​ به ترتیب بهره‌های تناسبی، انتگرالی و مشتقی هستند. نقش هر یک از این جملات در کنترل کوادروتور به شرح زیر است:

جمله تناسبی ($P$): این جمله متناسب با خطای فعلی عمل می‌کند و نیروی محرکه اصلی برای کاهش خطا را فراهم می‌آورد. بهره $Kp$​ بالا، سرعت پاسخ سیستم را افزایش می‌دهد اما می‌تواند منجر به نوسانات و ناپایداری شود.

جمله انتگرالی ($I$): این جمله با جمع‌آوری خطاهای گذشته، خطای حالت ماندگار ($steady-state error$) را از بین می‌برد. این ویژگی تضمین می‌کند که کوادروتور در نهایت دقیقاً به زاویه یا موقعیت مطلوب خود می‌رسد. با این حال، افزایش بهره $Ki$ می‌تواند پاسخ گذرا را کند کرده و فراجهش ($overshoot$) را افزایش دهد.

جمله مشتقی ($D$): این جمله با پاسخ به نرخ تغییرات خطا، رفتار آینده سیستم را پیش‌بینی می‌کند. عملکرد آن شبیه به یک ترمز است که نوسانات را میرا کرده و از فراجهش جلوگیری می‌کند و به پایداری سیستم کمک می‌کند. بهره $Kd$ بالا، پایداری را بهبود می‌بخشد اما سیستم را به نویز فرکانس بالا بسیار حساس می‌کند.


در کنترل کوادروتور، معمولاً از یک ساختار کنترلی آبشاری ($cascaded$) استفاده می‌شود که در آن دو حلقه $PID$ مجزا به کار گرفته می‌شود: یک حلقه داخلی برای کنترل وضعیت (زوایا) و یک حلقه خارجی برای کنترل موقعیت. حلقه خارجی خطای موقعیت را به عنوان ورودی دریافت کرده و زوایای رول و پیچ مطلوب را به عنوان خروجی تولید می‌کند. سپس حلقه داخلی این زوایای مطلوب را به عنوان نقطه تنظیم ($setpoint$) خود دریافت کرده و با کنترل گشتاورها، پرنده را به آن وضعیت هدایت می‌کند. کنترل‌کننده‌های $PID$ به دلیل پیاده‌سازی آسان و عملکرد رضایت‌بخش در شرایط پروازی محدود و مشخص، به طور گسترده در کوادروتورهای تجاری و تحقیقاتی اولیه مورد استفاده قرار گرفته‌اند.

با وجود کاربرد گسترده، کنترل‌کننده $PID$ مرسوم دارای محدودیت‌های ذاتی است که عملکرد آن را در کاربردهای پیچیده‌ای مانند کنترل کوادروتور به شدت به چالش می‌کشد.

\begin{enumerate}
    \item چالش تنظیم بهینه بهره‌ها: فرآیند یافتن مقادیر بهینه برای سه بهره $Kp​,Ki​,Kd$​ که به آن "تنظیم" ($Tuning$) گفته می‌شود، یک فرآیند پیچیده و زمان‌بر است. روش‌های کلاسیک مانند زیگلر-نیکولز یا آزمون و خطای دستی، اغلب به نتایج زیربهینه منجر می‌شوند و تضمینی برای عملکرد مطلوب در تمام شرایط ندارند. پیچیدگی این فرآیند تا حدی است که اغلب از آن به عنوان یک "هنر" یاد می‌شود تا یک علم دقیق، که خود نشان‌دهنده نبود یک رویکرد سیستماتیک برای سیستم‌های پیچیده است.

    \item افت عملکرد با تغییر پارامترهای سیستم: یک کنترل‌کننده $PID$ برای یک مجموعه شرایط خاص (مثلاً یک کوادروتور با باتری پر و بدون بار اضافی) تنظیم می‌شود. هرگونه تغییر در پارامترهای سیستم، مانند کاهش ولتاژ باتری در طول پرواز یا تغییر در جرم کل به دلیل حمل بار (مانند یک کوادروتور سم‌پاش)، باعث تغییر در دینامیک پرنده می‌شود. کنترل‌کننده $PID$ با بهره‌های ثابت قادر به تطبیق خود با این تغییرات نیست و در نتیجه عملکرد آن به شدت افت کرده و حتی ممکن است ناپایدار شود.

    \item ناتوانی در مدیریت غیرخطی بودن شدید: همانطور که در بخش اول نشان داده شد، دینامیک کوادروتور به شدت غیرخطی است. یک کنترل‌کننده خطی با بهره‌های ثابت نمی‌تواند عملکردی یکنواخت و بهینه را در سراسر پوشه پروازی (برای مثال، در مانورهای سریع با زوایای زیاد در مقابل پرواز شناور آرام) ارائه دهد.

    \item حساسیت به نویز: جمله مشتقی ($D$) به نویز فرکانس بالا که به طور معمول در خروجی سنسورهای $MEMS$ (مانند ژیروسکوپ و شتاب‌سنج) وجود دارد، بسیار حساس است. این نویز می‌تواند توسط جمله مشتقی تقویت شده و منجر به تولید سیگنال‌های کنترلی نامنظم و پرنوسان شود که به عملگرها (موتورها) آسیب می‌رساند و باعث اشباع آن‌ها می‌شود. این مشکل اغلب طراحان را مجبور می‌کند تا از فیلترهای پایین‌گذر استفاده کنند یا به طور کلی جمله مشتقی را حذف کرده و به یک کنترل‌کننده $PI$ با عملکرد ضعیف‌تر بسنده کنند.

    \item توازن ناکارآمد بین سرعت پاسخ و پایداری: در کنترل $PID$ کلاسیک، یک توازن ($trade-off$) ذاتی بین سرعت پاسخ و پایداری وجود دارد. افزایش بهره تناسبی ($Kp$) برای دستیابی به پاسخ سریع‌تر، معمولاً منجر به افزایش فراجهش و کاهش حاشیه پایداری می‌شود. دستیابی همزمان به زمان صعود کوتاه و فراجهش کم، با استفاده از روش‌های تنظیم مرسوم تقریباً غیرممکن است.

\end{enumerate}
محدودیت اصلی کنترل‌کننده $PID$ صرفاً دشواری تنظیم آن نیست، بلکه "شکنندگی بهینگی" آن است. به عبارت دیگر، هر مجموعه "بهینه" از بهره‌های $PID$، تنها برای یک لحظه خاص و یک مجموعه شرایط کاملاً مشخص، بهینه است. از آنجایی که کوادروتور یک سیستم پویا در حال تغییر مداوم است (جرم متغیر، ولتاژ باتری در حال کاهش، شرایط آیرودینامیکی متغیر)، یک کنترل‌کننده با پارامترهای ثابت، یک پارادایم اساساً ناقص برای این کاربرد است. مشکل، ساختار $PID$ نیست، بلکه ماهیت ایستا و غیرتطبیقی آن در یک دنیای دینامیک است. این تحلیل نشان می‌دهد که سیستم کنترل باید دارای قابلیت تطبیق‌پذیری برای حفظ عملکرد باشد، ویژگی‌ای که کنترل‌کننده $PID$ مرسوم فاقد آن است. این نتیجه‌گیری، بحث را از "$PID$ دشوار است" به "$PID$ اساساً برای این کاربرد نامناسب است" تغییر می‌دهد و راه را برای جستجوی راه‌حل‌های هوشمند و تطبیقی هموار می‌سازد.

\subsection{مقدمه‌ای بر منطق فازی}
منطق فازی، که توسط پروفسور لطفی‌زاده معرفی شد، شکلی از منطق چند-ارزشی است که برخلاف منطق کلاسیک بولین که تنها با دو ارزش "صحیح" (1) یا "غلط" (0) سروکار دارد، به متغیرها اجازه می‌دهد تا درجات عضویتی بین 0 و 1 داشته باشند. این ویژگی، منطق فازی را قادر می‌سازد تا با عدم قطعیت، ابهام و اطلاعات ناقص که مشخصه دنیای واقعی هستند، به شیوه‌ای مؤثر برخورد کند. منطق فازی در هسته خود، روشی برای فرموله کردن دانش و تجربه انسانی و استدلال‌های مبتنی بر زبان طبیعی در یک چارچوب ریاضی قابل محاسبه است. این پارادایم به جای تکیه بر مدل‌های ریاضی دقیق، از دانش طراح برای تصمیم‌گیری استفاده می‌کند.

یک سیستم استنتاج فازی (\lr{Fuzzy Inference System}) از چهار جز اصلی تشکیل شده است که با همکاری یکدیگر، یک ورودی عددی ($crisp$) را به یک خروجی عددی تبدیل می‌کنند.

\begin{enumerate}
    \item فازی‌سازی (\lr{Fuzzification}):
این مرحله، اولین گام در یک سیستم فازی است و وظیفه آن تبدیل مقادیر ورودی عددی و دقیق (مانند خطای زاویه برابر با 5- درجه) به مجموعه‌های فازی است. این کار از طریق "توابع عضویت" (\lr{Membership Functions}) انجام می‌شود. یک تابع عضویت، درجه تعلق (بین 0 و 1) یک مقدار ورودی به یک "متغیر زبانی" (\lr{Linguistic Variable}) را مشخص می‌کند. متغیرهای زبانی، مفاهیمی کیفی مانند "منفی بزرگ"، "صفر"، "مثبت کوچک" هستند. توابع عضویت می‌توانند اشکال مختلفی مانند مثلثی، ذوزنقه‌ای یا گوسی داشته باشند. برای مثال، خطای 5- درجه ممکن است 0.8 به مجموعه "منفی کوچک" و 0.2 به مجموعه "صفر" تعلق داشته باشد.


    \item پایگاه دانش (\lr{Knowledge Base}):
این بخش قلب هوشمند یک سیستم فازی است و از دو جز تشکیل شده است: پایگاه داده (تعریف توابع عضویت) و "پایگاه قوانین" (\lr{Rule Base}). پایگاه قوانین مجموعه‌ای از قوانین شرطی "اگر-آنگاه" ($IF-THEN$) است که استراتژی کنترل را بر اساس دانش خبره و به صورت زبانی تعریف می‌کند. این قوانین، روابط بین متغیرهای ورودی و خروجی فازی را بیان می‌کنند. یک قانون نمونه می‌تواند به این صورت باشد: "اگر ($IF$) خطا 'منفی بزرگ' است و ($AND$) نرخ تغییر خطا 'صفر' است، آنگاه ($THEN$) خروجی کنترل 'منفی بزرگ' است".

    \item موتور استنتاج (\lr{Inference Engine}):
این مؤلفه، مغز عملیاتی سیستم است که قوانین فازی را بر روی ورودی‌های فازی‌شده اعمال می‌کند تا یک خروجی فازی تولید کند. این فرآیند شامل دو مرحله است:

ارزیابی مقدم ($Antecedent$): با استفاده از عملگرهای فازی (مانند $AND$ که معمولاً با عملگر $min$ پیاده‌سازی می‌شود، و $OR$ که با $max$ پیاده‌سازی می‌شود)، درجه صدق بخش "اگر" ($IF$) هر قانون محاسبه می‌شود.

استلزام ($Implication$): نتیجه به‌دست‌آمده از مرحله قبل برای "شکل‌دهی" به بخش "آنگاه" ($THEN$) یا نتیجه ($Consequent$) هر قانون استفاده می‌شود. این کار معمولاً با "برش دادن" ($clipping$) یا "مقیاس‌دهی" ($scaling$) تابع عضویت خروجی انجام می‌شود.

در نهایت، نتایج فازی حاصل از تمام قوانینی که فعال شده‌اند، با یکدیگر "تجمیع" ($Aggregation$) می‌شوند تا یک مجموعه فازی واحد برای خروجی نهایی ایجاد کنند.

    \item فازی‌زدایی (\lr{Defuzzification}):
از آنجایی که سیستم‌های فیزیکی (مانند موتورهای کوادروتور) به یک سیگنال کنترلی عددی و دقیق نیاز دارند، خروجی فازی تجمیع‌شده باید به یک مقدار عددی تبدیل شود. این فرآیند، فازی‌زدایی نام دارد. روش‌های مختلفی برای این کار وجود دارد که متداول‌ترین آن‌ها "روش مرکز ثقل" (\lr{Centroid of Area}) است. در این روش، مرکز ثقل سطح زیر نمودار تابع عضویت خروجی تجمیع‌شده محاسبه می‌شود و به عنوان خروجی نهایی سیستم در نظر گرفته می‌شود.
    
\end{enumerate}

منطق فازی یک چارچوب قدرتمند برای فرموله کردن دانش شهودی و مبتنی بر هیوریستیک یک اپراتور انسانی خبره فراهم می‌کند. یک خلبان ماهر برای کنترل پرنده، معادلات دیفرانسیل را در ذهن خود حل نمی‌کند؛ بلکه بر اساس تجربه واکنش نشان می‌دهد ("پهپاد به سرعت در حال کله کردن به جلو است، پس باید یک گشتاور مخالف قوی اعمال کنم"). پایگاه قوانین فازی، یک پیاده‌سازی مستقیم و قابل محاسبه از همین دانش خبره است. منطق فازی این شکاف را با اجازه دادن به ما برای نوشتن هیوریستیک‌های انسانی در یک ساختار منظم (پایگاه قوانین) و استفاده از نظریه مجموعه‌های فازی برای درون‌یابی بین این قوانین، پر می‌کند و یک سطح کنترل غیرخطی و هموار ایجاد می‌نماید. این ویژگی آن را به ابزاری ایده‌آل برای سیستم‌هایی تبدیل می‌کند که مدل‌سازی دقیق آن‌ها دشوار است یا به پاسخ‌های تطبیقی و شبه‌انسانی نیاز دارند.


\newpage
\chapter{شبیه‌سازی کنترل‌کننده در نرم افزار متلب/سیمولینک}

پس از تبیین مبانی نظری، مرور ادبیات و انتخاب معماری کنترل‌کننده‌ی مقاوم \lr{Fuzzy-PID} در فصل‌های پیشین، در این فصل چارچوب پیاده‌سازی و ارزیابی عددی سامانه ارائه می‌شود. هدف اصلی، اعتبارسنجی عملکرد حلقه‌های کنترلی بر روی مدل دینامیکی شش‌درجه‌آزادی کوادروتور و سنجش میزان پایداری، دقت رهگیری و تاب‌آوری در برابر عدم‌قطعیت‌ها و اغتشاشات محیطی است. محیط پیاده‌سازی \lr{MATLAB/Simulink} انتخاب شده تا همخوان با نمادگذاری و متغیرهای حالت/ورودی معرفی‌شده در گزارش باشد (وضعیت
$$
[x,y,z,\phi,\theta,\psi]
$$
سرعت‌ها
$$
[u,v,w,p,q,r]
$$
و ورودی‌های کنترلی
$$
U_1 \text{ تا } U_4
$$
).

ساختار شبیه‌سازی به‌صورت آبشاری سازمان‌دهی شده است: حلقه بیرونی «کنترل موقعیت» فرمان‌های مسیر را به ارجاع‌های وضعیت تبدیل می‌کند و حلقه درونی «کنترل وضعیت/ارتفاع» این ارجاع‌ها را به گشتاورها و تراست متناظر رسانده و از طریق بخش «اختلاط فرامین» به اوامر چهار موتور نگاشت می‌کند؛ سپس مدل دینامیکی پرنده ($Plant$) پاسخ سامانه را تولید می‌کند. نمودار کلیِ فایل شبیه‌سازی و جریان سیگنال‌ها در ابتدای فصل نمایش داده می‌شود تا اجزای مسیر فرمان، کنترل‌کننده‌ها، اختلاط و پرنده ($Plant$) به‌صورت یکپارچه قابل ردیابی باشند.

سازمان فصل به این صورت است: ابتدا پیکربندی مدل و داده‌های ورودی (پارامترهای فیزیکی، شرایط اولیه، فرمان مسیر و ثبت داده‌ها) شرح داده می‌شود؛ سپس پیاده‌سازی کنترل‌کننده و جزئیات تنظیم آن ارائه می‌گردد؛ در ادامه سناریوهای آزمایشی و نتایج عددی/نموداری به‌همراه بحث و تحلیل مقایسه‌ای آورده می‌شود؛ و نهایتاً جمع‌ بندی فصل، نکات پیاده‌سازی و توصیه‌های کاربردی برای انتقال به سخت‌افزار بیان می‌گردد. این فصل پل میان طراحی نظری و ارزیابی عملی است و بستر قضاوت درباره کارایی و دوام راهبرد کنترلی پیشنهادی را فراهم می‌سازد.


\newpage
\section{مراحل ابتدایی شروع شبیه‌سازی}

\subsection{اضافه کردن فایل ها به محیط متلب}
ابتدا پوشه مربوط به پروژه و تمامی زیرپوشه های مربوط به آن باید به مسیر اضافه شوند،
روی پوشه مربوط به پروژه کلیک کرده و مانند تصویر زیر تمام فایل های مورد نیاز را به پروژه اضافه می‌کنیم:
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{CH04_PIC/Selected.jpg}
    \caption{نحوه اضافه کردن فایل ها به مسیر}
\end{figure}

بعد از انتخاب گزینه \lr{Selected Folders and Subfolders} تمامی فایل های موجود در شبیه سازی به مسیر متلب اضافه شده و قابل استفاده می باشد.

\subsection{بارگذاری مسیر برای کنترل موقعیت}
فرآیند بارگذاری مسیر یک مرحله مقدماتی و ضروری است که توسط بلوک خاکستری رنگ \lr{LOAD} در مدل سیمولینک مدیریت می‌شود. این بلوک وظیفه دارد تا پیش از شروع شبیه‌سازی، تمام داده‌های لازم را به محیط متلب و سیمولینک تزریق کند تا شبیه‌سازی با یک مجموعه اطلاعات منسجم و صحیح آغاز شود.

برای هر یک از سه مسیر تعریف‌شده، یک اسکریپت مجزای \lr{MATLAB} توسعه داده شده است تا مسیرهای مرجع مورد نیاز برای شبیه‌سازی را تولید کند. این اسکریپت‌ها با هدف ایجاد داده‌هایی با ساختار یکسان و سازگار با مدل سیمولینک طراحی شده‌اند. فرآیند کلی در هر سه اسکریپت شامل تعریف پارامترهای اصلی مسیر (مانند ابعاد، زمان و نرخ نمونه‌برداری)، تولید بردارهای زمانی و مختصات برای هر بخش از مسیر، ترکیب این بخش‌ها برای ساخت مسیر نهایی، و در نهایت بسته‌بندی داده‌ها در قالب یک ساختار به نام \lr{path} است که هر یک از مؤلفه‌های آن (\lr{x, y, z, psi}) یک شیء \lr{timeseries} متلب می‌باشد. این ساختار استاندارد، بارگذاری و استفاده از مسیرها را در محیط سیمولینک تسهیل می‌کند.

\newpage
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{CH04_PIC/Circle_code.png}
    \caption{کد استفاده شده برای ایجاد مسیر دایره ای}
\end{figure}

\newpage
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{CH04_PIC/Figure-Eight_code.png}
    \caption{کد استفاده شده برای ایجاد مسیر هشتی}
\end{figure}

\newpage
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{CH04_PIC/Diamond_code.png}
    \caption{کد استفاده شده برای ایجاد مسیر لوزی}
\end{figure}

\newpage
\begin{enumerate}
    \item \textbf{مسیر برخاست و حرکت دایره‌ای (\lr{Takeoff and Circle})}: این اسکریپت یک مسیر پایه و استاندارد برای ارزیابی پایداری و قابلیت رهگیری منحنی‌های هموار تولید می‌کند. کد ابتدا مسیر را به دو فاز مجزا تقسیم می‌کند: برخاست (\lr{Takeoff}) و حرکت دایره‌ای (\lr{Circle}). برای فاز برخاست، مختصات $X$ و $Y$ صفر نگه داشته می‌شوند و مختصات $Z$ با استفاده از دستور \lr{linspace} به صورت خطی از صفر تا ارتفاع مطلوب (۲ متر) در بازه زمانی مشخص افزایش می‌یابد. برای فاز حرکت دایره‌ای، ارتفاع ثابت باقی می‌ماند و مختصات $X$ و $Y$ با استفاده از معادلات پارامتری دایره \lr{(x=rcos(θ),y=rsin(θ))} محاسبه می‌شوند، که در آن زاویه \lr{theta} به صورت خطی از ۰ تا 
\lr{2π} تغییر می‌کند تا یک دایره کامل با شعاع $1.5$ متر ایجاد شود. در نهایت، داده‌های دو فاز به یکدیگر متصل شده و به همراه بردار زمانی کامل، در ساختار \lr{path} ذخیره می‌شوند.


    \item \textbf{مسیر برخاست، حرکت هشتی و فرود (\lr{Takeoff, Figure-Eight, Land})}: برای تولید این مسیر پیچیده و تهاجمی، اسکریپت مسیر را به سه فاز برخاست، حرکت هشتی و فرود تقسیم می‌کند. پس از فاز برخاست که مشابه مسیر قبلی است، فاز حرکت هشتی با استفاده از منحنی لیساژو (\lr{Lissajous curve}) پیاده‌سازی می‌شود. در این روش، مختصات $X$ و $Y$ با توابع سینوسی با فرکانس‌های متفاوت تعریف می‌شوند (معمولاً با نسبت فرکانس ۱ به ۲، مانند 
\lr{x=Asin(t),y=Bsin(2t)}
) تا شکل عدد هشت انگلیسی ایجاد شود. در این فاز، ارتفاع ثابت باقی می‌ماند. برای فاز فرود، موقعیت $X$ و $Y$ در نقطه پایانی مسیر هشتی ثابت نگه داشته شده و ارتفاع با دستور \lr{linspace} به صورت خطی از مقدار بیشینه به صفر کاهش می‌یابد. این سه بخش در نهایت با یکدیگر ترکیب شده و یک مسیر کامل و پیوسته را تشکیل می‌دهند که قابلیت مانورپذیری کنترل‌کننده را به چالش می‌کشد.


    \item  \textbf{مسیر الماسی (\lr{Diamond Path})}: رویکرد ساخت این مسیر با دو مسیر قبلی متفاوت است و بر اساس تعریف نقاط کلیدی (\lr{Waypoints}) انجام می‌شود. این اسکریپت ابتدا رئوس یک شکل لوزی را در صفحه افقی در ارتفاع مطلوب (۳ متر) تعریف می‌کند. مسیر از ترکیب یک فاز برخاست اولیه و چهار فاز حرکت خطی بین این رئوس تشکیل می‌شود. پس از فاز برخاست، کد با استفاده از دستور \lr{linspace}، به صورت متوالی بین هر دو رأس یک خط مستقیم تولید می‌کند. با اتصال این چهار پاره‌خط، یک مسیر الماسی شکل با گوشه‌های تیز ایجاد می‌شود. این روش تولید مسیر، به طور خاص برای ارزیابی پاسخ گذرای کنترل‌کننده به تغییرات ناگهانی در مسیر مرجع (ورودی پله در سرعت) بسیار مناسب است. در تمام مراحل، زاویه یاو (\lr{psi}) صفر در نظر گرفته شده تا تمرکز آزمون بر روی کنترل موقعیت باشد.

    
\end{enumerate}


\begin{figure}[H]
    \centering
    % Main caption for the entire figure arrangement
    \caption{شماتیک مسیرهای ایجاد شده برای آزمون عملکرد کوادروتور}

    % --- Top Row ---
    % First image (top-left)
    \begin{subfigure}{0.48\textwidth}
        \centering
        \includegraphics[width=\linewidth]{CH04_PIC/Takeoff and Circle.png}
        \caption{مسیر دایره‌ای}
    \end{subfigure}
    \hfill % Adds space between the two top images
    % Second image (top-right)
    \begin{subfigure}{0.48\textwidth}
        \centering
        \includegraphics[width=\linewidth]{CH04_PIC/Figure-Eight.png}
        \caption{مسیر هشتی}
    \end{subfigure}

    \vspace{0.5cm} % Adds some vertical space between rows

    % --- Bottom Row ---
    % Third image (bottom-center)
    \begin{subfigure}{0.5\textwidth} % Can be made wider if needed
        \centering
        \includegraphics[width=\linewidth]{CH04_PIC/Diamond_Path.png}
        \caption{مسیر لوزی یا الماسی}
    \end{subfigure}
\end{figure}

هر یک از سه مسیر پرواز تعریف‌شده، هدفمندانه برای ارزیابی جنبه‌ای خاص از عملکرد و مقاومت کنترل‌کننده کوادروتور انتخاب شده‌اند. این مسیرها صرفاً مسیرهای تصادفی نیستند، بلکه سناریوهای آزمون استانداردی هستند که هرکدام یک چالش کنترلی مشخص را مطرح می‌کنند.

مسیر اول، «برخاست و حرکت دایره‌ای»، به عنوان یک آزمون بنیادین عمل می‌کند. چالش اصلی در اینجا، ارزیابی قابلیت کنترل‌کننده در پایدارسازی اولیه و رهگیری یک مسیر هموار و پیوسته است. برخاست عمودی، توانایی حلقه کنترل ارتفاع در رسیدن به نقطه تنظیم مطلوب و غلبه بر نیروی گرانش را می‌سنجد. پس از آن، حرکت روی یک دایره با شعاع ثابت، عملکرد حلقه کنترل موقعیت را در تبدیل یک منحنی ساده به فرمان‌های رول و پیچ مناسب و پایدار ارزیابی می‌کند. این مسیر، محک اولیه برای سنجش کارایی پایه‌ی کنترل‌کننده در شرایط عادی و قابل پیش‌بینی است.

مسیر دوم، «حرکت هشتی»، سطح چالش را به شکل قابل توجهی افزایش می‌دهد. این مسیر برای آزمون مانورپذیری و عملکرد دینامیکی کنترل‌کننده در شرایط تهاجمی‌تر طراحی شده است. برخلاف دایره، مسیر هشتی دارای انحناهای متغیر و نقاط عطفی است که کنترل‌کننده را مجبور به اجرای سریع و مداوم تغییرات در زوایای رول و پیچ می‌کند. این سناریو به طور خاص، توانایی کنترل‌کننده در مدیریت کوپلینگ شدید بین دینامیک دورانی و انتقالی را به چالش می‌کشد؛ جایی که تغییرات سریع در وضعیت (\lr{attitude}) برای دنبال کردن مسیر، مستقیماً بر پایداری موقعیت تأثیر می‌گذارد. این آزمون نشان می‌دهد که آیا کنترل‌کننده می‌تواند در سرعت‌های بالاتر و در مانورهای پیچیده، پایداری و دقت خود را حفظ کند یا خیر.

در نهایت، مسیر سوم، «مسیر الماسی»، برای ارزیابی پاسخ گذرا (\lr{transient response}) و دقت کنترل‌کننده در برابر تغییرات ناگهانی طراحی شده است. هر گوشه از مسیر لوزی، معادل یک ورودی پله در سرعت مطلوب است. این تغییرات ناگهانی، رفتار کنترل‌کننده را در مواجهه با خطاهای بزرگ و آنی آشکار می‌سازد. هدف از این آزمون، سنجش معیارهایی مانند فراجهش (\lr{overshoot})، زمان نشست (\lr{settling time}) و توانایی سیستم در خنثی‌سازی نوسانات پس از یک تغییر سریع در مسیر مرجع است. این سناریو به خوبی نشان می‌دهد که کنترل‌کننده چقدر در مدیریت تغییرات ناگهانی فرمان، مقاوم و کارآمد است.


\subsection{بارگذاری یا ساخت مدل کوادروتور}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{CH04_PIC/Model.jpg}
    \caption{رابط گرافیک کاربری برای وارد کردن ابعاد کوادروتور}
\end{figure}
مدلسازی دینامیکی یک سیستم، اولین و یکی از اساسی‌ترین گام‌ها در فرآیند طراحی و تحلیل سیستم‌های کنترل است. نرم‌افزار ارائه‌شده، یک واسط گرافیکی به‌منظور تجمیع و پردازش پارامترهای فیزیکی یک کوادکوپتر جهت استخراج مدل ریاضی آن، مشخصاً جرم کل و ماتریس اینرسی، طراحی شده است. این مدل ریاضی، پایه‌ای برای شبیه‌سازی رفتار پروازی سیستم، طراحی کنترل‌کنندههای خطی و غیرخطی، و پیش‌بینی پاسخ پهپاد به فرامین کنترلی پیش از آزمون‌های پروازی واقعی است. در ادامه، تحلیل جامعی از پارامترهای وارد شده برای یک کوادکوپتر دست‌ساز ارائه می‌گردد.

این چهار نما اجزای مختلف رابط \lr{GUI\_Modeling} را برای پارامترسازی هندسی$–$جرمی کوادروتور نشان می‌دهند؛ کاربر با جابه‌جایی میان گزینه‌های \lr{Motors}، \lr{ESC’s}، \lr{Central HUB} و \lr{Arms}، همان اسکلت بدنه را می‌بیند اما برچسب‌گذاری هندسی و فیلدهای ورودی متناسب با جزء منتخب تغییر می‌کند تا ورود داده‌ها دقیق و منطبق با فیزیک سازه انجام شود. پس از تکمیل هر نما و فشردن دکمه \lr{Calculate}، ممان‌های اینرسی کل وسیله بر اساس قضیه محورهای موازی محاسبه و در خروجی‌های \(J_x\)، \(J_y\) و \(J_z\) نمایش داده می‌شود و وزن کل نیز در \lr{Gross Weight} گزارش می‌گردد؛ در صورت نیاز پیکربندی نهایی برای آرایش‌های \lr{"+"} و \lr{"X"} ذخیره می‌شود تا در ماتریس اختلاط و مدل دینامیکی به‌کار رود.

در نمای \lr{Motors} هندسه و جرم هر موتور ملخ نسبت به مرکز جرم بدنه معرفی می‌شود و نمادگذاری‌های \(m\)، \(d_m\)، \(h\) و \(r\) به‌ترتیب جرم یک موتور، فاصله افقی از مرکز جرم، اختلاف ارتفاع موتور نسبت به بازوها و شعاع مؤثر مجموعه ملخ را مشخص می‌کنند. این اطلاعات تعیین‌کننده سهم موتور در اینرسی حول محورهاست؛ اگر \(J_{m,\mathrm{c}}\) ممان ذاتی مجموعه موتور–ملخ حول مرکز خودش باشد، سهم آن در حول مبدأ بدنه طبق قضیه محورهای موازی برابر است با
$$
J_m \;=\; J_{m,\mathrm{c}} \;+\; m\,(d_m^2+h^2),
$$
و برای چهار موتور، جمع این مقادیر به ممان کل افزوده می‌شود. به‌علاوه، تغییر علامت \(h\) یا جابه‌جایی \(d_m\) می‌تواند کوپل‌های ناخواسته بین محورها ایجاد کند و به‌همین دلیل این نما با محورهای بدنه \((x,y,z)\) و بردارهای \((x_c,y_c,z_c)\) کاربر را در تشخیص جهت‌گیری‌های صحیح یاری می‌دهد.

در نمای \lr{ESC’s} فرض می‌شود هر \lr{ESC} در امتداد یکی از بازوها نصب شده و با پارامترهای \(m\)، \(a\)، \(b\) و \(d_s\) توصیف می‌گردد که به‌ترتیب جرم، عرض، طول و فاصله افقی \lr{ESC} از مرکز جرم بدنه هستند. این جزء معمولاً یک منشور مستطیلیِ نازک مدل می‌شود و ممان ذاتی آن حول مرکز خودش با تقریب منشور نازک محاسبه شده و سپس با جابه‌جایی \(d_s\) به مبدأ بدنه منتقل می‌شود؛ بنابراین اگر \(J_{e,\mathrm{c}}\) ممان ذاتی باشد، سهم هر \lr{ESC} برابر است با
$$
J_e \;=\; J_{e,\mathrm{c}} \;+\; m\,d_s^2,
$$
که نشان می‌دهد حتی جرم‌های کوچکِ الکترونیک، وقتی دور از مرکز جرم نصب شوند، می‌توانند اثر معنی‌داری بر \(\mathbf{J}\) داشته باشند. نمایش گرافیکیِ این نما محل تقریبی نصب \lr{ESC} و جهت طول$–$عرض آن را نسبت به محورها روشن می‌کند تا ورود \(a\) و \(b\) با چیدمان واقعی سازگار باشد.

در نمای \lr{Central HUB} بخش میانی بدنه به‌صورت استوانه‌ای با جرم \(m\)، شعاع \(r\) و ارتفاع کل \(H\) مدل می‌شود و چون این جزء دقیقاً پیرامون مرکز جرم قرار دارد، ممان‌های ذاتی استوانه نقش پررنگی دارند. برای یک استوانه توپر، ممان‌ها حول مرکز جرم طبق روابط استاندارد برابرند با
$$
J_z \;=\; \tfrac{1}{2}\,m\,r^2,\qquad
J_x \;=\; J_y \;=\; \tfrac{1}{12}\,m\,(3r^2+H^2),
$$
و چون مرکز این قطعه بر مرکز جرم منطبق است، افزودن جملات انتقالیِ قضیه محورهای موازی لازم نیست. این نما به‌صورت شماتیک محل توپی مرکزی، اندازه شعاع و ارتفاع آن را روی بدنه نمایش می‌دهد تا انتخاب \(r\) و \(H\) با هندسه واقعی هم‌خوان بماند و اثر تغییر ابعاد مرکزی بر توزیع جرم و سختی دورانی به‌خوبی دیده شود.

در نمای \lr{Arms} هر بازو به‌صورت میله‌ای با جرم \(m\)، شعاع مؤثر \(r\)، طول کل \(L\) و آفست \(d_a\) نسبت به مرکز جرم معرفی می‌شود؛ \(d_a\) جابه‌جایی نقطه میانیِ بازو از مرکز جرم را بیان می‌کند. برای مدل‌سازی بازو به‌عنوان میله نازک، ممان حول محوری عمود بر طول و گذرنده از مرکز خودِ بازو تقریباً
$$
J_{\perp} \;\approx\; \tfrac{1}{12}\,m\,L^2
$$
و حول محور طولی با تقریب پوسته نازک
$$
J_{\parallel} \;\approx\; m\,r^2
$$
است. با انتقال به مبدأ بدنه، سهم هر بازو حول محورهای لخت به‌صورت
$$
J_{\text{\lr{arm}}} \;=\; J_{\perp} \;+\; m\,d_a^2
$$
به ممان کل اضافه می‌شود و انتخاب آرایش \lr{"+"} یا \lr{"X"} روی هم‌نهی این سهم‌ها و تقارن \(J_x\) و \(J_y\) اثر مستقیم دارد. نمایش گرافیکیِ این نما، طول \(L\)، شعاع مؤثر \(r\) و جایگاه \(d_a\) را نسبت به محورها مشخص می‌کند تا سازگاری پارامترهای واردشده با هندسه واقعیِ شاسی به‌صورت شهودی کنترل شود.

در مجموع، این چهار نما زنجیره‌ای منسجم برای توصیف اجزای اصلی کوادروتور فراهم می‌کنند تا پس از تبدیل یکاها و اعمال قضیه محورهای موازی، ممان‌های اینرسی کل به‌صورت
$$
\mathbf{J}\;=\;\mathrm{diag}(J_x,\,J_y,\,J_z)\;=\;\sum_{i\in\{\text{\lr{motors, ESCs, hub, arms}}\}}\!\!\!\!\!\big(J_{i,\mathrm{c}}+m_i d_i^2\big)
$$
دقیقاً محاسبه و به مدل \lr{Simulink} تزریق شود؛ به این ترتیب تغییر هر پارامتر در هر نما اثر خود را بلافاصله در \(\mathbf{J}\) و وزن کل نشان می‌دهد و مسیر طراحی مکانیکی و کنترل به‌طور یکپارچه پیش می‌رود.


\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{CH04_PIC/Quad-struct.jpg}
    \caption{مشخضات فیزیکی کوادروتور}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{CH04_PIC/Quad_test.jpg}
    \caption{کوادروتور استفاده شده برای تست}
\end{figure}

\section*{بخش اول: خصوصیات جرمی و هندسی}
این بخش به تعریف مشخصات فیزیکی اجزای اصلی سازه پهپاد اختصاص دارد که در نهایت، مرکز جرم و ماتریس اینرسی کل سیستم را تعیین می‌کنند.

برای \textbf{موتورها ($Motors$)} و \textbf{اسپید کنترل‌کنندهها ($ESCs$)}، مقادیر جرمی به ترتیب ۶۸ و ۲۹ گرم به همراه ابعاد فیزیکی و فواصل نصب آن‌ها از مرکز جرم ($dm$ و $ds$) وارد شده است. این مقادیر با مشخصات فنی قطعات منتخب (موتور $AX-2810Q$ و اسپید کنترل‌کننده $Emax 30A$) مطابقت دارند. جرم این قطعات، به دلیل قرارگیری در انتهای بازوها و با فاصله قابل توجه از مرکز، تأثیر بسزایی بر ممان‌های اینرسی سیستم، به ویژه حول محور عمودی ($Jz$)، خواهد داشت.

\textbf{بدنه مرکزی ($Central HUB$)} به عنوان هسته اصلی سازه، با جرمی معادل ۴۰۰ گرم و شعاع ۵ سانتی‌متر مدل‌سازی شده است. این جرم، علاوه بر صفحات اصلی بدنه، می‌تواند وزن مجموعه اویونیک شامل کنترل‌کننده پرواز، واحد $GPS$، گیرنده رادیویی و سایر حسگرها را نیز نمایندگی کند که از نظر مهندسی، یک تقریب قابل قبول است.

بخش \textbf{بازوها ($Arms$)} که نقش اهرم‌های انتقال نیرو و گشتاور را ایفا می‌کنند، با مقادیر اصلاح‌شده و دقیقی مدل‌سازی شده‌اند. جرم ۲۰۰ گرم برای هر بازو با توجه به جنس آلومینیومی و پایه‌های اتصال موتور، مقداری واقع‌بینانه است. همچنین، طول بازو ($L$) به مقدار ۲۰ سانتی‌متر با توجه به فاصله موتور تا مرکز ($dm$ برابر ۲۵ سانتی‌متر) و شعاع بدنه مرکزی (۵ سانتی‌متر)، اکنون از نظر هندسی کاملاً صحیح و سازگار است. صحت این پارامترها برای محاسبه دقیق ممان اینرسی ضروری است.

\section*{بخش دوم: خصوصیات آیرودینامیکی و دینامیکی موتور}
این بخش رفتار هر واحد موتور-ملخ را به عنوان یک عملگر ($Actuator$) توصیف می‌کند و برای شبیه‌سازی دقیق نیروهای تولیدی، حیاتی است.

پارامترهای \textbf{$Ct$ (ضریب تراست)} و \textbf{$Cq$ (ضریب گشتاور)}، اصلی‌ترین مشخصه‌های آیرودینامیکی سیستم پیشران هستند. این ضرایب، رابطه بین سرعت زاویه‌ای موتور ($\omega$) و نیروی تراست ($T$) و گشتاور آیرودینامیکی ($Q$) را از طریق روابط غیرخطی زیر مدل‌سازی می‌کنند:
$$T = C_t \cdot \omega^2$$
$$Q = C_q \cdot \omega^2$$
مقادیر وارد شده، که معمولاً از آزمون‌های عملی روی تراست استند به دست می‌آیند، امکان ترجمه دقیق سرعت موتور به نیروهای وارد بر بدنه پهپاد را فراهم می‌سازند.

پارامترهای \textbf{$Cr$} و \textbf{$b$} یک مدل خطی مرتبه اول را برای رابطه بین سیگنال ورودی از کنترل‌کننده (درصد تراتل) و سرعت خروجی موتور ($RPM$) ارائه می‌دهند. این تقریب خطی، پیچیدگی‌های دینامیکی درایور $ESC$ و موتور را ساده‌سازی کرده و طراحی کنترل‌کننده را تسهیل می‌بخشد. \textbf{\lr{Time Constant} (ثابت زمانی)}، پارامتری دینامیکی است که سرعت پاسخ موتور به تغییرات در فرمان ورودی را مشخص می‌کند. این مقدار برابر با زمانی است که پاسخ پله موتور به حدود $63.2$ درصد مقدار نهایی خود می‌رسد و مقادیر کوچکتر، نشان‌دهنده پاسخ سریع‌تر و قابلیت مانورپذیری بالاتر پهپاد است. در نهایت، \textbf{\lr{Min Throttle} (حداقل تراتل)} یک مقدار آستانه عملی برای جلوگیری از خاموش شدن موتورها در حین پرواز است.

\section*{بخش سوم: خروجی‌های محاسباتی و نتیجه‌گیری نهایی}
خروجی نهایی این مدلسازی، \textbf{\lr{Gross Weight} (جرم کل)} و \textbf{ممان‌های اینرسی ($Jx$, $Jy$, $Jz$)} است. ممان اینرسی، مقاومت سیستم در برابر شتاب‌گیری زاویه‌ای را توصیف می‌کند. همانطور که در نتایج دیده می‌شود، به دلیل تقارن ساختاری پهپاد، ممان اینرسی حول محورهای $Roll$ و $Pitch$ کاملاً برابر است ($Jx = Jy$). مقدار بزرگتر برای $Jz$ نیز صحیح و قابل انتظار است، زیرا بخش قابل توجهی از جرم سیستم (موتورها و بازوها) در فاصله شعاعی زیادی از محور عمودی $Z$ توزیع شده است.

در مجموع، مدل ارائه‌شده با پارامترهای اصلاح‌شده، یک تقریب دقیق و معتبر از پهپاد واقعی است. این مدل، پایه‌ای قابل اعتماد برای مراحل بعدی پروژه، یعنی طراحی و تنظیم دقیق کنترل‌کنندههای پرواز در محیط شبیه‌سازی، فراهم می‌آورد. توصیه نهایی برای تکمیل مدل، افزودن جرم باتری به جرم بدنه مرکزی است تا وزن کل مدل با وزن پروازی واقعی (\lr{All-Up Weight}) پهپاد تطبیق کامل یابد.



\subsection{بارگذاری شرایط اولیه کوادروتور}
در شبیه‌سازی این پروژه، مرحله مقداردهی اولیه یک گام حیاتی برای تعریف نقطه شروع محاسبات و تضمین تکرارپذیری آزمون‌ها است که توسط بلوک $LOAD$ در مدل سیمولینک مدیریت می‌شود. در این فرآیند، شرایط اولیه کوادروتور از یک فایل داده با نام \lr{IC-OnGround-MotorsOff.mat} بارگذاری می‌گردد.

این فایل حاوی یک ساختار ($struct$) در متلب است که وضعیت کامل پرنده را در لحظه صفر از طریق ۱۶ فیلد مجزا تعریف می‌کند. این فیلدها شامل موقعیت در سه محور (\lr{X, Y, Z})، وضعیت زاویه‌ای (\lr{Phi, Theta, Psi})، سرعت‌های خطی و زاویه‌ای در چارچوب بدنه (\lr{U, V, W, P, Q, R}) و سرعت اولیه چهار موتور ($w1$ تا $w4$) می‌باشند. نام‌گذاری این فایل به وضوح سناریوی پیش‌فرض را توصیف می‌کند: شروع شبیه‌سازی از یک حالت سکون کامل در مبدأ مختصات، با وضعیتی کاملاً افقی و موتورهای خاموش، که در آن تمامی ۱۶ مقدار اولیه صفر تنظیم شده‌اند. این داده‌ها به صورت مستقیم برای مقداردهی اولیه به انتگرال‌گیرهای مدل دینامیکی ($Plant$) به کار رفته و نقطه شروع دقیق و یکسانی را برای تمامی آزمون‌ها تضمین می‌کنند.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{CH04_PIC/IC.jpg}
    \caption{شرایط اولیه کوادروتور}
\end{figure}
برای تغییر دادن هرکدام از شرایط اولیه به سادگی می‌توان روی پارامتر مورد نظر \lr{double-click} کرد و مقدار موردنظر را بارگذاری کرد.



\newpage
\section{طراحی کنترل کننده \lr{PID} برای موقعیت}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{CH04_PIC/Quad_simulation.jpg}
    \caption{شماتیک کلی فایل شبیه‌سازی سیمولینک کنترل‌کننده موقعیت کوادروتور}
    \label{Quad_simulation}
\end{figure}
این شکل نمای کلی فایل شبیه‌سازی کنترل کوادروتور در \lr{Simulink} را نشان می‌دهد که در آن زنجیره تولید فرمان از «مرجع مسیر» تا «فرمان‌های چهار موتور» و نیز حلقه بازخورد حالت‌ها به‌صورت یکپارچه دیده می‌شود. در سمت چپ، ناحیه \lr{LOAD} مسئول بارگذاری داده‌های اولیه است؛ این داده‌ها شامل فرمان‌های مسیر به‌صورت \lr{timeseries}، پارامترهای مدل کوادروتور و شرایط اولیه حالت‌هاست تا شبیه‌سازی با مجموعه اطلاعات سازگار شروع شود. بلوک \lr{Path Command} همان منبع مرجع مسیر است و بردار «فرمان مسیر» را تولید می‌کند که در ادامه به بلوک \lr{Position Controller} وارد می‌شود. \lr{Position Controller} علاوه بر فرمان مسیر، «بازخورد حالت» را نیز از مسیر \lr{State Input} دریافت می‌کند و با محاسبه خطاهای موقعیتی، آن را به «فرمان وضعیت» تبدیل می‌نماید؛ به عبارت دیگر، مرجع‌های مناسب برای رول، پیچ، یاو و ارتفاع را می‌سازد تا حلقه درونی بتواند پایداری بدنه را تضمین کند. خروجی این بلوک با عنوان \lr{Attitude Cmd} به \lr{Attitude Controller} ارسال می‌شود و هم‌زمان همان \lr{State Input} نیز برای محاسبه خطاهای زاویه‌ای و ارتفاعی به این کنترل‌کننده داده می‌شود. \lr{Attitude Controller} پس از مقایسه وضعیت مطلوب و وضعیت واقعی، چهار اصلاحه کنترلی تولید می‌کند که در شکل با عناوین \lr{Roll (Phi) Correction}، \lr{Pitch (Theta) Correction}، \lr{Yaw (Psi) Correction} و \lr{Alt. (Z) Correction} مشخص شده‌اند؛ این اصلاحه‌ها معادل نیازهای نیروی تراست کل و گشتاورهای سه‌محوره بدنه هستند و ورودی‌های مرحله بعدی را تشکیل می‌دهند. در بلوک \lr{Control Mixing} این چهار کمیت پیوسته به فرمان‌های مجزای هر موتور نگاشت می‌شود و خروجی‌های \lr{mc1} تا \lr{mc4} شکل می‌گیرند؛ این نگاشت معمولاً با یک ماتریس اختلاط انجام می‌شود به‌صورت
$$
\begin{bmatrix} mc_1 \\ mc_2 \\ mc_3 \\ mc_4 \end{bmatrix}
=
\mathbf{M}
\begin{bmatrix} T \\ \tau_{\phi} \\ \tau_{\theta} \\ \tau_{\psi} \end{bmatrix},
$$
که در آن \(T\) تراست کل و \(\tau_{\phi},\tau_{\theta},\tau_{\psi}\) به‌ترتیب گشتاورهای رول، پیچ و یاو هستند و \(\mathbf{M}\) با توجه به آرایش پره‌ها، بازوی موثر و ضرایب تراست/درگ تعیین می‌شود. فرمان‌های موتوریِ \lr{mc1} تا \lr{mc4} سپس به بلوک \lr{Plant} اعمال می‌شوند که مدل دینامیکی شش‌درجه‌آزادی کوادروتور را پیاده‌سازی می‌کند؛ این مدل با انتگرال‌گیری از معادلات حرکت، بردار حالت را به‌روزرسانی کرده و در خروجی سیگنال \lr{States} را تولید می‌کند که هم برای ثبت نتایج (\lr{yout}) و هم برای بستن حلقه بازخورد (\lr{State Input}) استفاده می‌شود. برای تحلیل و ارائه نتایج، ناحیه \lr{Plot: States + Motors command} به ترسیم پاسخ‌های زمانی حالت‌ها و فرمان‌های موتوری اختصاص دارد و بخش \lr{Animation} نیز یک نمایش سه‌بعدی از مسیر و وضعیت پرنده فراهم می‌کند تا درک شهودی از رفتار سیستم به دست آید؛ این تجسم‌ها بر دینامیک اثر ندارند و صرفاً مصرف‌کننده داده‌اند. در پایین شکل ناحیه \lr{Build New Model} قرار دارد که به‌منزله فضای کمکی برای ساخت یا پیکربندی سناریوهای جدید یا جایگزینی مدل‌ها به کار می‌رود. به‌طور خلاصه، جریان اطلاعات از چپ به راست ابتدا مرجع مسیر را به مرجع‌های وضعیت تبدیل می‌کند، سپس در حلقه درونی به گشتاورها و تراست بدل می‌شود و پس از اختلاط، به فرمان‌های چهار موتور می‌رسد؛ هم‌زمان، بردار حالت
$$
\mathbf{x} = [\,x,\;y,\;z,\;\phi,\;\theta,\;\psi,\;u,\;v,\;w,\;p,\;q,\;r\,]^{\top}
$$
در \lr{Plant} محاسبه شده و از طریق مسیر بازخورد به کنترل‌کننده‌های بیرونی و درونی تغذیه می‌گردد تا یک سامانه حلقه‌بسته آبشاری با امکان پایش عددی و تجسم گرافیکی در بستر \lr{Simulink} شکل گیرد.



\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{CH04_PIC/Load.jpg}
    \caption{بلوک بارگذاری مسیر، مدل کوادروتور و شرایط اولیه}
\end{figure}
این تصویر نمایانگر بلوک \lr{LOAD} در فایل شبیه‌سازی است؛ ناحیه‌ای مقدماتی که پیش از آغاز حل عددی، تمامی داده‌های ورودیِ لازم را به محیط \lr{Simulink} تزریق می‌کند و تضمین می‌نماید که زنجیره کنترلی با یک مجموعه منسجم از اطلاعات آغاز به کار کند. مأموریت اصلیِ این بخش سه گروه داده را در بر می‌گیرد: نخست «فرمان‌های مسیر» به‌صورت \lr{timeseries} که معمولاً برداری از مراجع موقعیت و سرجهت است، مانند
$$
\mathbf{r}_d(t)=\big[x_d(t),\,y_d(t),\,z_d(t),\,\psi_d(t)\big]^{\top},
$$
و از طریق بلوک‌های \lr{From Workspace} به حلقه «کنترل موقعیت» اعمال می‌شود؛ برای سازگاری با حل‌گر لازم است بردار زمان یکنواخت و صعودی بوده و نوع داده یا به‌صورت شیء \lr{timeseries} و یا ساختار استاندارد \lr{struct} با فیلدهای \lr{time} و \lr{signals} تعریف شود تا ابعاد و نمونه‌زمان‌ها به‌درستی تفسیر گردند. دوم «پارامترهای مدل کوادروتور» که به‌طور معمول شامل جرم \(m\)، ممان‌های اینرسی
\(
\mathbf{I}=\mathrm{diag}(I_{xx},I_{yy},I_{zz})
\),
فاصله بازو \(L\)، ضرایب تراست و درگ ملخ‌ها و ثابت گرانش \(g\) است و اغلب در قالب یک ساختار یکپارچه (مثلاً \lr{model}) در \lr{Base Workspace} قرار می‌گیرد تا هم در بلوک \lr{Plant} و هم در ماتریس اختلاطِ فرمان‌ها مورد استفاده واقع شود. سوم «شرایط اولیه» که وضعیت آغازین دستگاه را مشخص می‌کند، برای نمونه
$$
\mathbf{x}(0)=\big[x_0,\,y_0,\,z_0,\,\phi_0,\,\theta_0,\,\psi_0,\,u_0,\,v_0,\,w_0,\,p_0,\,q_0,\,r_0\big]^{\top},
$$
و به‌صورت مستقیم در انتگرال‌گیرهای \lr{Plant} و سازوکارهای ثبت خروجی به‌کار می‌رود. از منظر پیاده‌سازی، \lr{LOAD} معمولاً به اسکریپت‌های \lr{.m} یا فایل‌های \lr{.mat} متصل است و از طریق رویداد آغازین \lr{InitFcn} یا دکمه ماسک، متغیرهای موردنیاز را بارگذاری می‌کند؛ رعایت یکاهای سازگار (سامانه \lr{SI})، قرارداد چارچوب مختصات و نام‌گذاری دقیق متغیرها در این گام حیاتی است، زیرا بلوک‌های پایین‌دست مانند \lr{Position Controller}، \lr{Attitude Controller} و \lr{Control Mixing} مستقیماً به همین مقادیر اتکا دارند. در نتیجه، بلوک \lr{LOAD} نقش «درگاه داده» را ایفا کرده و امکان تعریف سناریوهای گوناگون شبیه‌سازی را تنها با تعویض فایل مسیر، جدول پارامترها یا بردار شرایط اولیه فراهم می‌سازد؛ به این ترتیب بدون تغییر در شماتیک اصلی، تکرارپذیری آزمایش‌ها، کنترل نسخه و جابه‌جایی سریع میان سناریوهای مختلف ممکن می‌شود.


\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{CH04_PIC/Plots.jpg}
    \caption{بلوک انیمیشن، نمودارها و ساخت مدل جدید کوادروتور}
\end{figure}
در این تصویر سه ناحیه کمکی از فایل شبیه‌سازی نمایش داده شده است که کارِ دیده‌بانی، تجسم و توسعه سناریوهای جدید را بر عهده دارند. ناحیه چپ-بالا با عنوان \lr{Plot: States + Motors command} ماژول ترسیم است که روی داده‌های ثبت‌شده شبیه‌سازی عمل می‌کند؛ در اینجا سیگنال‌های حالت و فرمان‌های موتوری که به‌کمک بلوک‌های \lr{To Workspace} یا ثبت خودکار \lr{Simulink} به‌صورت \lr{timeseries} در فضای کاری ذخیره می‌شوند، خوانده شده و نمودارهای زمانی تولید می‌گردد. معمولاً بردار حالت به‌صورت
$$
\mathbf{x}(t)=\big[x(t),\,y(t),\,z(t),\,\phi(t),\,\theta(t),\,\psi(t),\,u(t),\,v(t),\,w(t),\,p(t),\,q(t),\,r(t)\big]^{\top}
$$
و فرمان موتورها به‌صورت
$$
\mathbf{u}(t)=\big[mc_1(t),\,mc_2(t),\,mc_3(t),\,mc_4(t)\big]^{\top}
$$
ثبت می‌شود تا بتوان کیفیت پاسخ گذرا، اشباع محرک‌ها و توازن بار بین موتورها را ارزیابی کرد.
ناحیه راست-بالا با عنوان \lr{Animation} وظیفه تجسم سه‌بعدی حرکت کوادروتور را دارد و با دریافت موقعیت \(\mathbf{p}(t)=[x(t),y(t),z(t)]^{\top}\) و زوایا \((\phi,\theta,\psi)\) پیکربندی بدنه را در دستگاه لخت به‌روزرسانی می‌کند. مبنای این نمایش، تبدیل چارچوب بدنه به لخت از طریق ماتریس چرخش \(\mathbf{R}_{IB}(\phi,\theta,\psi)\) است تا جهت‌گیری لحظه‌ای پرنده درست اعمال شود؛ مسیر طی‌شده، بردارهای سرعت و حتی فرمان‌های موتوری می‌توانند به‌صورت \lr{overlay} نمایش داده شوند. این بخش بر دینامیک تأثیری ندارد و صرفاً مصرف‌کننده داده است، اما برای راستی‌آزمایی شهودی و کشف خطاهای علامتی (مانند جابه‌جایی محورها یا ترتیب زوایا) بسیار مؤثر است. در نسخه‌های جدید \lr{MATLAB} ممکن است برای روانی نمایش، کاهش نرخ رسم یا استفاده از \lr{video logging} توصیه شود.

نوار پایینی با عنوان \lr{Build New Model} فضای کار برای توسعه سناریوها یا نسخه‌های جدید مدل است؛ در این بخش کاربر می‌تواند با اجرای اسکریپت‌های پارامتری، ایجاد \lr{Variant Subsystem} برای کنترل‌کننده‌های مختلف، یا کپی‌برداری از اسکلت مدل موجود، یک پیکربندی تازه بسازد و آن را به زنجیره اصلی متصل کند. معمولاً پارامترهای فیزیکی، ماتریس اختلاط، تنظیمات حل‌گر و نرخ نمونه‌برداری در همین ناحیه تنظیم شده و با \lr{callbacks} راه‌اندازی (مانند \lr{InitFcn}) به مدل تزریق می‌شوند تا تکرارپذیری تضمین شود. به این ترتیب سه بخشِ \lr{Plot}، \lr{Animation} و \lr{Build New Model} حلقه کامل «داده‌برداری \(\rightarrow\) تجسم \(\rightarrow\) توسعه» را کنار هسته دینامیک و کنترل فراهم می‌کنند و امکان مستندسازی دقیق نتایج و بازآفرینی سریع آزمایش‌ها را مهیا می‌سازند.



\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{CH04_PIC/Animation.jpg}
    \caption{رابط گرافیک کاربری برای نمایش عملکرد کوادروتور}
\end{figure}
این نما خروجی ماژول \lr{Animation} را در یک محیط تعاملی نشان می‌دهد که در آن رفتار کوادروتور هم‌زمان از دو زاویه مکمل «وضعیت» و «مکان» قابل مشاهده است. پنل سمت چپ با عنوان \lr{Attitude} پیکربندی لحظه‌ای بدنه را در دستگاه مختصات سه‌بعدی نمایش می‌دهد؛ حلقه‌های سبز نمایانگر صفحه ملخ‌ها و بدنه رنگی، شاسی پرنده را صورت‌بندی می‌کند. بر فراز بدنه دو بردار مرجع ترسیم شده که مطابق راهنمای بالای شکل، بردار سیاه سرعت خطی و بردار قرمز سرعت زاویه‌ای را نمایش می‌دهند؛ بنابراین در هر گام زمانی می‌توان بزرگی و جهت \(\mathbf{v}(t)\) و \(\boldsymbol{\omega}(t)\) را نسبت به محورهای بدنه ارزیابی کرد. محورهای \lr{X}، \lr{Y} و \lr{Z} با برچسب‌گذاری شفاف در صحنه حضور دارند تا زاویه‌های چرخش و تغییر راستا به‌صورت بصری و بی‌ابهام قابل پیگیری باشد؛ اسکرول‌بارهای کنار و پایین پنجره نیز برای بزرگ‌نمایی، جابه‌جایی و تنظیم سطح دید در حین پخش به کار می‌روند تا کاربر بدون توقف شبیه‌سازی بتواند روی جزئیات مورد نظر تمرکز کند.

پنل سمت راست با عنوان \lr{Position} مسیر سه‌بعدی حرکت را بر فراز صفحه زمین ترسیم می‌کند؛ نشانگرهای دایره‌ای آبی، نمونه‌های زمانیِ مسیر را مشخص می‌سازند و پیوستگی آن‌ها تغییرات لحظه‌ای موقعیت \((x(t),y(t),z(t))\) را آشکار می‌کند. صفحه سبز رنگ کفِ صحنه مرز \lr{ground plane} را می‌نمایاند و درک فاصله عمودی را ساده می‌کند، به‌ویژه در مانورهایی که فراز (\lr{altitude}) تغییرات چشمگیر دارد. در ستون کنترلی سمت راست، دکمه \lr{Stop} اجرای انیمیشن را متوقف/ازسر می‌گیرد، باکس \lr{Frame Rate} نرخ فریم را بر حسب فریم بر ثانیه تنظیم می‌کند تا تعادل میان روانی نمایش و بار محاسباتی برقرار شود، و شاخص \lr{Time (s)} زمان جاری شبیه‌سازی را به‌طور زنده گزارش می‌کند؛ این سه مولفه امکان همگام‌سازی دقیق با نمودارهای زمانی و تحلیل‌های کمی را فراهم می‌آورند. مجموعه دکمه‌های \lr{Default}، \lr{X-Y View}، \lr{X-Z View} و \lr{Y-Z View} نیز نماهای ازپیش‌تعریف‌شده دوربین را فراهم می‌کنند تا با یک کلیک بتوان مسیر را در صفحه افقی، نماهای جانبی عمودی یا دید پیش‌فرض مرور کرد؛ تغییر دیدگاه به‌ویژه برای ارزیابی فراجهش ارتفاعی، انحراف جانبی و کیفیت رهگیری مسیر در هر صفحه بسیار سودمند است.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{CH04_PIC/PositionControl.jpg}
    \caption{بلوک کنترل موقعیت در نرم‌افزار سیمولینک}
\end{figure}
این نمودار، ساختار حلقه بیرونی «کنترل موقعیت» را نشان می‌دهد که چگونه فرمان‌های \lr{Path Cmd} شامل \lr{X\_cmd}، \lr{Y\_cmd}، \lr{Alt\_Cmd} و \lr{Psi\_cmd} به‌همراه بازخورد \lr{State Input} از جمله \lr{X}، \lr{Y}، \lr{Psi} و سرعت‌های بدنه \lr{U} و \lr{V} وارد زنجیره تولید «فرمان وضعیت» می‌شوند. هسته این زنجیره، بلوک سبزرنگ \lr{Error Rotations} است که به‌جای کار کردن مستقیم با خطای مکان در چارچوب لَخت، ابتدا خطای افقی را به چارچوب بدنه می‌چرخاند تا کنترل‌پذیر توسط وضعیت (رول/پیچ) شود. بنابراین با استفاده از زاویه یاو $\psi$ داریم:
$$
\begin{bmatrix}
e_{x_b} \\[2pt] e_{y_b}
\end{bmatrix}
=
\begin{bmatrix}
\cos\psi & \sin\psi \\
-\sin\psi & \cos\psi
\end{bmatrix}
\begin{bmatrix}
x_{\text{$cmd$}}-x \\[2pt] y_{\text{$cmd$}}-y
\end{bmatrix}.
$$

بر این مبنا یک «سرعت مطلوب در چارچوب بدنه» ساخته می‌شود و آنگاه کنترل‌کننده‌های \lr{Theta Command Control} و \lr{Phi Command Control} هر یک با قانون \lr{PD} روی خطای سرعت بدنه عمل می‌کنند و به ترتیب $\theta_{\text{$cmd$}}$ و $\phi_{\text{$cmd$}}$ را می‌سازند. فرم معمولِ این دو نگاشت (با اشباع $\pm 8^\circ$) به‌شکل زیر است:
$$
\theta_{\text{$cmd$}}
=
\mathrm{sat}_{\pm 8^\circ}\!\Big(
K_{p,\theta}\,\big(v^{d}_{x_b}-v_{x_b}\big)
+
K_{d,\theta}\,\tfrac{d}{dt}\big(v^{d}_{x_b}-v_{x_b}\big)
\Big),
$$
$$
\phi_{\text{\lr{cmd}}}
=
\mathrm{sat}_{\pm 8^\circ}\!\Big(
K_{p,\phi}\,\big(v^{d}_{y_b}-v_{y_b}\big)
+
K_{d,\phi}\,\tfrac{d}{dt}\big(v^{d}_{y_b}-v_{y_b}\big)
\Big).
$$

در این‌جا $v_{x_b}$ و $v_{y_b}$ همان مولفه‌های سرعت بدنه‌اند که در مدل با \lr{U} و \lr{V} اندازه‌گیری می‌شوند و $v^{d}_{x_b}$ و $v^{d}_{y_b}$ خروجی‌های بلوک \lr{Error Rotations} هستند. در سمت راست، فرمان‌های $\phi_{\text{cmd}}$ و $\theta_{\text{cmd}}$ به‌همراه عبور مستقیم \lr{Psi\_cmd} و \lr{Alt\_Cmd} در باس \lr{Attitude\_Cmd} جمع می‌شوند و از طریق درگاه \lr{Attitude Cmd} و اشاره‌گر \lr{Goto Quadcopter Dynamics Block} به حلقه درونی و مدل دینامیکی ارسال می‌گردند. ایده کلیدی این معماری آن است که چون متغیر واقعاً کنترل‌پذیر با وضعیت، «سرعت در چارچوب لَخت» است، ابتدا خطای مکان به سرعت مطلوب در چارچوب بدنه نگاشته می‌شود و سپس همین سرعت مطلوب به فرمان وضعیت تبدیل می‌گردد؛ بدین‌ترتیب مسیر \lr{position} $\rightarrow$ \lr{body-velocity} $\rightarrow$ \lr{attitude} به‌صورت منسجم و قابل تنظیم پیاده می‌شود.


\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{CH04_PIC/AttitudeControl.jpg}
    \caption{بلوک کنترل وضعیت در نرم‌افزار سیمولینک}
\end{figure}
این دیاگرام معماری حلقه درونیِ «کنترل وضعیت» را نشان می‌دهد که در آن چهار تنظیم‌گر مستقل برای رول، پیچ، یاو و ارتفاع بر مبنای قانون‌های \lr{PID/PD} پیاده‌سازی شده‌اند و ورودی‌های خود را از دو گذرگاه \lr{Attitude Cmd} و \lr{State Input} می‌گیرند. گذرگاه نخست حامل مراجع $\phi_{\text{$cmd$}}$، $\theta_{\text{$cmd$}}$، $\psi_{\text{$cmd$}}$ و $z_{\text{$cmd$}}$ است که از حلقه بیرونی یا اپراتور می‌آیند؛ گذرگاه دوم نیز حالت‌های اندازه‌گیری‌شده را در اختیار می‌گذارد، شامل زوایا $\phi$، $\theta$، $\psi$ و نرخ‌های بدنه $p$، $q$، $r$ (که در مدل با برچسب‌های \lr{P}، \lr{Q}، \lr{R} نشان داده شده‌اند) و همچنین ارتفاع $z$. در مسیر رول (بلوک آبی) خطای زاویه به‌صورت $e_\phi=\phi_{\text{$cmd$}}-\phi$ تشکیل می‌شود و با یک قانون \lr{PID} با ضرایب نمونه درج‌شده روی بلوک ($K_p=2$، $K_i=0.5$، $K_d=1$) به «تصحیح رول» نگاشت می‌شود؛ ترم مشتق عملاً با فیدبک نرخ $p$ نقش میراکنندگی را ایفا می‌کند تا پاسخ سریع بدون فراجهش زیاد حاصل شود. صورت‌بندی متداول فرمان رول چنین است:
$$
u_\phi \;=\; K_{p,\phi}\,(\phi_{\text{$cmd$}}-\phi)\;-\;K_{d,\phi}\,p\;+\;K_{i,\phi}\!\int (\phi_{\text{$cmd$}}-\phi)\,dt,
$$
که پس از اشباع انتگرال (آنتی‌وینداپ) با کران‌های $\pm1$ به خروجی «\text{\lr{Phi Correction}}» فرستاده می‌شود. مسیر پیچ (بلوک قرمز) به‌طور مشابه با $e_\theta=\theta_{\text{$cmd$}}-\theta$ و همان ضرایب نمونه ($K_p=2$، $K_i=0.5$، $K_d=1$) عمل می‌کند و با بهره‌گیری از نرخ $q$ ترم مشتق مؤثر را می‌سازد؛ خروجی این کانال «\text{\lr{Theta Correction}}» است:
$$
u_\theta \;=\; K_{p,\theta}\,(\theta_{\text{$cmd$}}-\theta)\;-\;K_{d,\theta}\,q\;+\;K_{i,\theta}\!\int (\theta_{\text{$cmd$}}-\theta)\,dt.
$$
در مسیر یاو (بلوک سبز) به‌سبب کندی دینامیک و حساسیت جهت‌گیری، بهره مشتق بزرگ‌تری انتخاب شده است ($K_p=2$، $K_i=1$، $K_d=5$) تا تغییرات نرخ $r$ به‌خوبی میرا شود و انحراف سرفرمان به‌سرعت خاموش گردد؛ خروجی این کانال «\text{\lr{Psi Correction}}» خواهد بود:
$$
u_\psi \;=\; K_{p,\psi}\,(\psi_{\text{$cmd$}}-\psi)\;-\;K_{d,\psi}\,r\;+\;K_{i,\psi}\!\int (\psi_{\text{$cmd$}}-\psi)\,dt.
$$
کانال ارتفاع (بلوک بنفش) با مرجع $z_{\text{$cmd$}}$ و حالت $z$ کار می‌کند و علاوه بر تنظیم‌گر \lr{PID} با ضرایب نمونه ($K_p=2$، $K_i=1.1$، $K_d=3.3$)، یک جزء پیشخور ثابت نیز دارد که در بلوک با عنوان \lr{Gravity Offset = 57.1762} نمایش داده شده است؛ این بایاس معادل نیروی/دریچه شناوری نامی است که وزن را خنثی می‌کند و فرمان تنظیم‌گر صرفاً «تصحیح حول شناوری» را تولید می‌نماید. فرم رایج فرمان ارتفاع به‌شکل زیر نوشته می‌شود:
$$
u_z \;=\; u_{\text{$hover$}}\;+\;K_{p,z}\,(z_{\text{$cmd$}}-z)\;+\;K_{i,z}\!\int (z_{\text{$cmd$}}-z)\,dt\;-\;K_{d,z}\,\dot z,
$$
که در آن $u_{\text{$hover$}}$ همان بایاس گرانشی و $\dot z$ می‌تواند از فیلتر مشتق یا حسگر ارتفاع-سرعت محاسبه شود. در هر چهار مسیر، «\text{\lr{Integral Saturation: on}}» با کران‌های $\pm1$ فعال است تا از پدیده بادشدگی انتگرال در اشباع‌ها جلوگیری شود و در نتیجه بازیابی نرم پس از اشباع تضمین گردد. خروجی‌های چهار تنظیم‌گر به‌ترتیب با برچسب‌های «\text{\lr{Roll (Phi) Correction}}»، «\text{\lr{Pitch (Theta) Correction}}»، «\text{\lr{Yaw (Psi) Correction}}» و «\text{\lr{Alt. (Z) Correction}}» از بلوک‌ها خارج شده و در مرحله بعدیِ اختلاط فرامین به گشتاورهای بدنه و تراست کل نگاشت می‌شوند؛ این معماری با جداسازی محورها، تنظیم و تیونینگ را ساده می‌کند، امکان زمان‌بندی نمونه‌برداری ناهم‌نرخ را فراهم می‌سازد و به‌دلیل استفاده از نرخ‌های بدنه $p,q,r$ به‌عنوان فیدبک مشتق، پاسخ گذرا را پایدار و قابل‌پیش‌بینی نگه می‌دارد.


\subsection{نتایج طراحی کنترل کننده موقعیت برای مسیر دایره‌ای}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{CH04_PIC/circle-result.png}
    \caption{عملکرد کوادروتور در مسیر دایره‌ای}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{CH04_PIC/Circle-states.png}
    \caption{عملکرد کوادروتور در مسیر دایره‌ای}
\end{figure}

\subsection*{تحلیل نتایج طراحی کنترل کننده موقعیت برای مسیر دایره‌ای}
مسیر دایره‌ای به عنوان یک آزمون بنیادین، قابلیت کنترل‌کننده در پایدارسازی اولیه و ردیابی یک مسیر هموار و پیوسته را ارزیابی می‌کند. این سناریو، محک اولیه برای سنجش کارایی پایه کنترل‌کننده در شرایط عادی و قابل پیش‌بینی است.

\paragraph{تحلیل ردیابی موقعیت (\lr{Position Tracking}):}نمودارهای موقعیت در محورهای $X$ و $Y$ نشان می‌دهند که کنترل‌کننده با موفقیت قادر به دنبال کردن یک مسیر منحنی است، اما این ردیابی با مقداری خطای تاخیر (\lr{Tracking Lag}) همراه است. مسیر واقعی (خط‌چین قرمز) همواره کمی عقب‌تر از مسیر مرجع (خط آبی) حرکت می‌کند. این پدیده در سیستم‌های کنترل فیدبک طبیعی است و نشان‌دهنده زمان مورد نیاز برای واکنش سیستم به خطاست. در محور $Z$ (ارتفاع)، کنترل‌کننده پس از یک فراجهش ($Overshoot$) کوچک در مرحله برخاست اولیه، به خوبی توانسته ارتفاع ۲ متری را در حین اجرای مانور دایره‌ای حفظ کند. این پایداری در ارتفاع نشان می‌دهد که کنترل‌کننده به خوبی از پس جبران نیروی گرانش برآمده و کوپلینگ بین حرکات افقی و عمودی را تا حد قابل قبولی مدیریت کرده است.

\paragraph{تحلیل ردیابی زوایا (\lr{Angles Tracking}):}
نمودارهای زوایا، علت رفتار مشاهده‌شده در موقعیت را آشکار می‌سازند. برای ایجاد حرکت دایره‌ای، کنترل‌کننده به درستی فرمان‌های سینوسی و کسینوسی را برای زوایای $Roll$ (غلتش) و $Pitch$ (پیچش) صادر کرده است (خط آبی). با این حال، پاسخ واقعی پهپاد (خط‌چین قرمز) به این فرمان‌ها با نوسانات ($Oscillations$) قابل توجهی همراه است. این لرزش‌های با فرکانس بالا، نشانه‌ی کلاسیک یک کنترل‌کننده وضعیت (\lr{Attitude Controller}) با تنظیمات تهاجمی است؛ به احتمال زیاد، بهره تناسبی ($Kp$) بسیار بالا و بهره مشتقی ($Kd$) بسیار پایین است. این نوسانات در زوایا، دلیل اصلی عدم ردیابی کاملاً صاف و دقیق در مسیر افقی است. زاویه $Yaw$ (انحراف) نیز با وجود فرمان صفر، دچار نوسانات کوچکی شده است که نشان‌دهنده اثرات کوپلینگ دینامیکی ناشی از حرکات $Roll$ و $Pitch$ است.

\paragraph{تحلیل تجسم سه‌بعدی (\lr{3D Visualization}):}
نمودار سه‌بعدی، تحلیل‌های فوق را به صورت بصری تایید می‌کند. پهپاد (خط آبی) شکل کلی دایره مرجع (خط‌چین قرمز) را دنبال می‌کند، اما مسیر آن به دلیل نوسانات کنترل‌کننده وضعیت، کاملاً صاف و هموار نیست و لرزش‌های کوچکی در آن دیده می‌شود.


\subsection{نتایج طراحی کنترل کننده موقعیت برای مسیر هشتی}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{CH04_PIC/8-results.jpg}
    \caption{عملکرد کوادروتور در مسیر هشتی}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{CH04_PIC/8-states.png}
    \caption{عملکرد کوادروتور در مسیر هشتی}
\end{figure}


\subsection*{تحلیل نتایج طراحی کنترل کننده موقعیت برای مسیر هشتی}
مسیر هشتی با داشتن انحناهای متغیر و نقاط عطف، سطح چالش را افزایش داده و توانایی مانورپذیری کنترل‌کننده در شرایط تهاجمی‌تر را می‌آزماید. این آزمون به طور خاص مدیریت کوپلینگ شدید بین دینامیک دورانی و انتقالی را ارزیابی می‌کند.

\paragraph{تحلیل ردیابی موقعیت (\lr{Position Tracking}):}
عملکرد ردیابی در این مسیر پیچیده‌تر، ضعف‌های کنترل‌کننده را بیشتر نمایان می‌کند. در محورهای $X$ و $Y$، پهپاد شکل کلی عدد هشت را دنبال می‌کند، اما با خطای ردیابی و تاخیر بسیار بیشتری نسبت به مسیر دایره‌ای. به خصوص در نقاطی که انحنای مسیر تغییر جهت می‌دهد (در مرکز شکل هشت)، پهپاد دچار بیش‌جهش ($Overshoot$) شده و از مسیر مرجع فاصله می‌گیرد. این نشان می‌دهد که کنترل‌کننده در پاسخ به تغییرات سریع در فرمان، به اندازه کافی چابک نیست. کنترل ارتفاع ($Z$) همچنان نسبتاً پایدار است، اما نوسانات بزرگ‌تر در حرکات افقی، اغتشاشات بیشتری را به محور عمودی نیز منتقل کرده و باعث نوسانات جزئی در ارتفاع پرواز می‌شود.

\paragraph{تحلیل ردیابی زوایا (\lr{Angles Tracking}):}
این نمودارها دلیل اصلی عملکرد ضعیف در موقعیت را نشان می‌دهند. فرمان‌های صادر شده برای $Roll$ و $Pitch$ اکنون بسیار تهاجمی‌تر و با تغییرات سریع‌تری همراه هستند. پاسخ واقعی پهپاد به این فرمان‌ها، نوسانات بسیار شدید و با دامنه‌ی بزرگ‌تر را به نمایش می‌گذارد. این لرزش‌های شدید نشان می‌دهد که تنظیمات $PID$ کنترل‌کننده وضعیت برای چنین مانورهای سریعی کاملاً ناپایدار است و سیستم در آستانه واگرایی قرار دارد. این نوسانات شدید در زوایا، مانع از این می‌شود که پهپاد بتواند نیروی تراست خود را با دقت در جهت مورد نظر اعمال کند و در نتیجه، خطای بزرگی در ردیابی موقعیت ایجاد می‌شود. کنترل زاویه $Yaw$ نیز در این مانور پیچیده، به دلیل گشتاورهای واکنشی شدید ناشی از تغییرات سریع سرعت موتورها، دچار انحرافات بزرگتری تا حدود ۴ درجه شده است که نشان‌دهنده کنترل ضعیف در این محور است.

\paragraph{تحلیل تجسم سه‌بعدی (\lr{3D Visualization}):}
مسیر سه‌بعدی به وضوح نشان می‌دهد که پهپاد (خط آبی) در دنبال کردن مسیر مرجع (خط‌چین قرمز) با مشکل مواجه است. پهپاد به جای حرکت نرم روی منحنی‌ها، مسیر را با لرزش و با "بریدن گوشه‌ها" طی می‌کند که این امر مستقیماً ناشی از ناتوانی کنترل‌کننده وضعیت در فراهم کردن پایداری لازم برای اجرای چنین مانور دقیقی است.


\subsection{نتایج طراحی کنترل کننده موقعیت برای مسیر لوزی}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{CH04_PIC/diamond-results.png}
    \caption{عملکرد کوادروتور در مسیر لوزی}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{CH04_PIC/diamond-states.png}
    \caption{عملکرد کوادروتور در مسیر لوزی}
\end{figure}

\subsection*{تحلیل نتایج طراحی کنترل کننده موقعیت برای مسیر لوزی}
مسیر لوزی با گوشه‌های تیز، به طور خاص برای ارزیابی پاسخ گذرا (\lr{Transient Response}) و مقاومت کنترل‌کننده در برابر تغییرات ناگهانی (معادل ورودی پله در سرعت) طراحی شده است.

\paragraph{تحلیل ردیابی موقعیت (\lr{Position Tracking}):}
همانطور که انتظار می‌رفت، کنترل‌کننده در ردیابی این مسیر با بیشترین چالش مواجه شده است. در محورهای $X$ و $Y$، پهپاد به جای دنبال کردن گوشه‌های تیز، مسیر را به شدت گرد کرده و با بیش‌جهش ($Overshoot$) قابل توجهی از مسیر مرجع منحرف می‌شود. این رفتار نشان می‌دهد که سیستم قادر به تغییر جهت آنی نیست و پس از هر تغییر مسیر ناگهانی، زمانی برای نشست و بازگشت به مسیر نیاز دارد (\lr{Settling Time}). این عملکرد، محدودیت فیزیکی پهپاد و همچنین ضعف کنترل‌کننده در دفع سریع خطاهای بزرگ را نشان می‌دهد. کنترل ارتفاع ($Z$) در این آزمون نیز تحت تاثیر شدیدترین تغییرات قرار گرفته و با هر تغییر جهت ناگهانی در صفحه افقی، دچار افت و خیز می‌شود که نشان‌دهنده کوپلینگ بسیار شدید دینامیکی در این شرایط است.

\paragraph{تحلیل ردیابی زوایا (\lr{Angles Tracking}):}
این نمودارها به اوج ناپایداری کنترل‌کننده اشاره دارند. در هر گوشه از لوزی، کنترل‌کننده فرمان‌های تقریباً آنی (شبیه به پله) برای $Roll$ و $Pitch$ صادر می‌کند. پاسخ واقعی سیستم به این فرمان‌ها، نوسانات بسیار شدید، بزرگ و دیرپا است. این رفتار نشان می‌دهد که تنظیمات فعلی $PID$ به هیچ وجه برای مدیریت چنین تغییرات شدیدی مناسب نیست و سیستم برای مدت طولانی پس از هر فرمان، در حال لرزیدن است. این لرزش مداوم در زوایا، دلیل اصلی عدم توانایی پهپاد در اجرای پیچ‌های تیز و ردیابی دقیق مسیر لوزی است.

\paragraph{تحلیل تجسم سه‌بعدی (\lr{3D Visualization}):}
مسیر پرواز سه‌بعدی به بهترین شکل، تمام تحلیل‌های فوق را خلاصه می‌کند. پهپاد (خط آبی) به جای پرواز روی یک لوزی، یک مسیر منحنی و گرد شده را با نوسانات زیاد طی می‌کند که فاصله قابل توجهی از مسیر مرجع (خط‌چین قرمز) دارد. این تصویر، نیاز مبرم به تنظیم مجدد و دقیق بهره‌های کنترل‌کننده، به ویژه افزایش قابل توجه بهره مشتقی ($Kd$) برای میرا کردن نوسانات، را به وضوح نشان می‌دهد.

برای مشاهده انیمیشن‌ها می توانید به لینک \href{https://drive.google.com/drive/folders/1Tpw8xs0goq8wsWbWr61g4NjHx9qBnspm?usp=drive_link}{گوگل درایو} مربوطه مراجعه کنید.


\newpage
\subsection{تیون کردن ضرایب کنترل‌کننده}
پس از فرآیند تنظیم دقیق بهره‌های کنترل‌کننده $PID$، عملکرد دینامیکی سیستم کوادروتور به صورت چشمگیری بهبود یافته است. نتایج شبیه‌سازی جدید نشان‌دهنده گذار موفقیت‌آمیز از یک سیستم ناپایدار و پرنوسان به یک سیستم کنترل حلقه بسته پایدار، دقیق و با عملکرد بالا است. در این بخش، بهبودهای حاصل شده در سه حوزه کلیدی کنترل وضعیت ($Attitude$)، ردیابی موقعیت ($Position$) و کنترل انحراف ($Yaw$) به تفصیل تحلیل و با نتایج پیشین مقایسه می‌گردد.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{CH04_PIC/Circle_tune_results.png}
    \caption{عملکرد کوادروتور تیون شده در مسیر دایره‌ای}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{CH04_PIC/Circle_tune_states.png}
    \caption{عملکرد کوادروتور تیون شده در مسیر دایره‌ای}
\end{figure}


\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{CH04_PIC/Tuned-results.png}
    \caption{عملکرد کوادروتور تیون شده در مسیر هشتی}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{CH04_PIC/Tuned-states.png}
    \caption{عملکرد کوادروتور تیون شده در مسیر هشتی}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{CH04_PIC/diamond_tune_results.png}
    \caption{عملکرد کوادروتور تیون شده در مسیر لوزی}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{CH04_PIC/diamond_tune_states.png}
    \caption{عملکرد کوادروتور تیون شده در مسیر لوزی}
\end{figure}

\section*{بهبود بنیادین در پایداری کنترل وضعیت (\lr{Attitude Control})}
مهم‌ترین و اساسی‌ترین بهبود، در عملکرد حلقه داخلی کنترل، یعنی کنترل وضعیت (زوایای $Roll$ و $Pitch$)، مشاهده می‌شود. در نسخه‌های پیشین، کنترل‌کننده وضعیت به دلیل تنظیم نبودن بهره‌ها، یک پاسخ به شدت ناپایدار و پرنوسان از خود نشان می‌داد. سیستم با فرکانس و دامنه بالا حول مقادیر مرجع لرزش داشت که این امر عملاً هرگونه تلاش برای ردیابی دقیق موقعیت را غیرممکن می‌ساخت.

اکنون، همانطور که در نمودارهای \lr{Angles Tracking} به وضوح دیده می‌شود، این نوسانات شدید به طور کامل حذف شده‌اند. پاسخ واقعی زوایای \lr{Roll (Phi)} و \lr{Pitch (Theta)} (خط‌چین قرمز) اکنون به نرمی، با سرعت بالا و با حداقل بیش‌جهش (\lr{Overshoot})، فرمان‌های صادر شده (خط آبی) را دنبال می‌کند. این رفتار، نمونه‌ای عالی از یک پاسخ بهینه و میرا شده (\lr{Critically Damped}) است. این پایداری در حلقه داخلی، فونداسیون و پیش‌نیاز اصلی برای دستیابی به عملکرد مطلوب در حلقه‌های بالاتر کنترل است و نشان می‌دهد که بهره‌های \lr{Kp}، \lr{Ki} و \lr{Kd} اکنون در یک تعادل صحیح برای ایجاد واکنشی سریع و در عین حال پایدار قرار دارند.

\section*{افزایش چشمگیر دقت در ردیابی مسیر (\lr{Position Tracking})}
پایداری به دست آمده در کنترل وضعیت، مستقیماً منجر به بهبود فوق‌العاده در عملکرد حلقه خارجی، یعنی کنترل موقعیت، شده است. پیش از این، به دلیل ناتوانی پهپاد در حفظ زوایای صحیح، خطای ردیابی مسیر در محورهای \lr{X} و \lr{Y} بسیار زیاد بود و سیستم در دنبال کردن مسیرهای پیچیده مانند مسیر هشتی با شکست مواجه می‌شد.

نتایج جدید در نمودارهای \lr{Position Tracking} نشان می‌دهند که مسیر واقعی (خط‌چین قرمز) اکنون با دقت بسیار بالایی بر مسیر مرجع (خط آبی) منطبق است. خطای تاخیر (\lr{Tracking Lag}) به شدت کاهش یافته و بیش‌جهش‌های بزرگی که قبلاً در محور \lr{Z (Altitude)} مشاهده می‌شد، تقریباً از بین رفته و سیستم به سرعت در ارتفاع مطلوب تثبیت می‌شود. این دقت بالا در ردیابی، در نمودار تجسم سه‌بعدی (\lr{3D Visualization}) به بهترین شکل قابل مشاهده است؛ جایی که مسیر پرواز واقعی (خط آبی) تقریباً به طور کامل روی مسیر مرجع (خط‌چین قرمز) قرار گرفته است. این انطباق کامل، گواهی بر موفقیت کنترل‌کننده در ترجمه دقیق خطای موقعیت به فرمان‌های صحیح زاویه‌ای و اجرای بی‌نقص آن فرمان‌ها توسط حلقه پایدار وضعیت است.

\section*{بهبود در کنترل انحراف (\lr{Yaw Control})}
کنترل زاویه \lr{Yaw} نیز بهبود قابل توجهی داشته است. نوسانات پراکنده و خطاهای بزرگی که پیش از این در این محور مشاهده می‌شد، جای خود را به یک پاسخ بسیار پایدارتر داده است. اگرچه هنوز اغتشاشات کوچکی در این محور به دلیل کوپلینگ دینامیکی با حرکات دیگر وجود دارد، اما این اغتشاشات به سرعت توسط کنترل‌کننده میرا شده و پهپاد توانایی خود در حفظ جهت‌گیری صحیح را به خوبی نشان می‌دهد.

فرآیند تنظیم موفقیت‌آمیز کنترل‌کننده، عملکرد پهپاد شبیه‌سازی شده را از یک حالت ناپایدار و غیرقابل استفاده به یک سیستم رباتیک هوایی دقیق، پایدار و قابل اعتماد تبدیل کرده است. بهبودهای حاصل شده در تمامی جنبه‌های پروازی، نشان‌دهنده درک صحیح از دینامیک سیستم و تنظیم درست پارامترهای کنترلی است. این مدل پایدار و خوش‌تنظیم، اکنون یک بستر معتبر برای آزمون‌های پیچیده‌تر، مانند ارزیابی مقاومت در برابر اغتشاشات یا پیاده‌سازی روی سخت‌افزار واقعی، محسوب می‌شود.

این سه آزمون، به ترتیب درجه سختی، برای ارزیابی جنبه‌های مختلف عملکرد کنترل‌کننده از پایداری پایه تا مانورپذیری تهاجمی طراحی شده‌اند. تحلیل مقایسه‌ای این نتایج، یک دید کامل از شخصیت دینامیکی و محدودیت‌های کنترل‌کننده تنظیم‌شده فراهم می‌آورد.

\textbf{مسیر دایره‌ای: آزمون پایداری و ردیابی پیوسته:}
این مسیر به عنوان یک آزمون بنیادین، قابلیت کنترل‌کننده در دنبال کردن یک مسیر هموار با انحنای ثابت را می‌سنجد. نقطه قوت اصلی که در این آزمون آشکار می‌شود، پایداری بنیادین و دقت بالای کنترل‌کننده در شرایط عملیاتی نرمال است. همان‌طور که در نمودارها مشخص است، کنترل‌کننده به خوبی توانسته است با هماهنگی بین محورهای $Roll$ و $Pitch$، یک مسیر دایره‌ای را با خطای ردیابی بسیار کم دنبال کند. پایداری در حفظ ارتفاع در حین اجرای مانور نیز نشان‌دهنده توانایی کنترل‌کننده در مدیریت همزمان چند وظیفه و غلبه بر اثرات کوپلینگ دینامیکی است. با این حال، نقطه ضعف جزئی کنترل‌کننده نیز در همین آزمون نمایان می‌شود. در ابتدای شروع مانور دایره‌ای، یک فراجهش ($Overshoot$) کوچک در پاسخ زوایای $Roll$ و $Pitch$ مشاهده می‌شود که نشان‌دهنده یک واکنش اولیه کمی تهاجمی است. علاوه بر این، یک تاخیر جزئی ($Lag$) بین مسیر واقعی و مرجع وجود دارد که ضعفی کوچک در سرعت همگرایی کامل را نشان می‌دهد.

\textbf{مسیر هشتی: آزمون مانورپذیری و پاسخ دینامیکی:}
مسیر هشتی با داشتن انحناهای متغیر و نقاط عطف، چالش را افزایش داده و توانایی کنترل‌کننده در مدیریت مانورهای دینامیکی‌تر را ارزیابی می‌کند. نقطه قوت کلیدی کنترل‌کننده که در این آزمون برجسته می‌شود، چابکی و پاسخ دینامیکی مطلوب آن است. کنترل‌کننده با موفقیت توانسته است از پس تغییرات مداوم در جهت و میزان انحنای مسیر برآید و بدون ایجاد ناپایداری، شکل کلی عدد هشت را دنبال کند. این امر نشان‌دهنده توانایی آن در مدیریت کوپلینگ شدید بین محورها در حین مانورهای پیچیده است. اما نقطه ضعف اصلی که در این آزمون آشکار می‌شود، کاهش دقت ردیابی تحت فشارهای دینامیکی بالا است. خطای بین مسیر واقعی و مرجع، به خصوص در بخش‌های با بیشترین انحنا، به وضوح بیشتر از مسیر دایره‌ای است. همچنین، نمودار زاویه $Yaw$ نشان‌دهنده اغتشاشات بزرگتری است؛ این بدان معناست که گشتاورهای واکنشی ناشی از مانورهای تهاجمی $Roll$ و $Pitch$، توانایی کنترل‌کننده $Yaw$ در حفظ دقیق جهت را به چالش کشیده و ضعف آن در دفع کامل این اغتشاشات را نشان می‌دهد.

\textbf{مسیر لوزی: آزمون پاسخ گذرا و مقاومت:}
این مسیر با گوشه‌های تیز، سخت‌ترین آزمون بوده و به طور خاص، پاسخ گذرا و مقاومت کنترل‌کننده در برابر تغییرات فرمان ناگهانی را می‌سنجد. برجسته‌ترین نقطه قوت کنترل‌کننده در این آزمون، مقاومت ($Robustness$) و پاسخ گذرای بسیار خوب آن است. نمودارهای زوایا نشان می‌دهند که با وجود فرمان‌های تقریبا آنی و پله‌ای در هر گوشه از مسیر، پاسخ واقعی سیستم به سرعت و با میرایی مناسب (\lr{well-damped}) به مقدار جدید همگرا می‌شود و دچار نوسانات شدید یا ماندگار نمی‌گردد. این نشان‌دهنده یک تنظیم بسیار موفق، به‌خصوص در بهره مشتقی ($Kd$) است که توانسته انرژی ناشی از تغییرات شدید را به خوبی دفع کند. نقطه ضعف اصلی کنترل‌کننده در این آزمون، ناتوانی در ردیابی دقیق هندسی مسیر است. پهپاد به جای اجرای پیچ‌های ۹۰ درجه، مسیر را "گرد می‌کند". این "ضعف" در واقع یک محدودیت فیزیکی است و نشان می‌دهد که کنترل‌کننده قادر به اجرای فرمان‌های غیرممکن (تغییر سرعت آنی) نیست. همچنین، در هر پیچ، یک فراجهش قابل توجه در موقعیت $X$ و $Y$ مشاهده می‌شود که نشان‌دهنده تمایل کنترل‌کننده به بیش‌جهش در هنگام بازیابی از خطاهای بزرگ و ناگهانی است.

در مجموع، کنترل‌کننده $PID$ تنظیم‌شده یک تعادل مهندسی موفق بین دقت، سرعت و پایداری را به نمایش می‌گذارد. قوت اصلی آن، پایداری مقاوم در تمام شرایط، از حرکات نرم تا مانورهای تهاجمی، و داشتن یک پاسخ زاویه‌ای سریع و به خوبی میرا شده‌است. ضعف اصلی آن، کاهش تدریجی دقت ردیابی با افزایش پیچیدگی و تهاجمی بودن مسیر مرجع است. این کنترل‌کننده یک نمونه عالی از یک سیستم کنترل واقع‌بینانه است که عملکرد قابل اعتمادی را ارائه می‌دهد، اما محدودیت‌های خود را نیز در مواجهه با فرمان‌های شدید به وضوح نشان می‌دهد.

در ادامه ضرایب کنترل‌کننده پس از تیون کردن را مشاهده می‌کنید:

\begin{figure}[H] 
    \centering
    \subfloat[ضرایب کنترل‌کننده برای کنترل وضعیت]{
        \includegraphics[width=0.48\linewidth]{CH04_PIC/AC.jpg}
    }
    \hfill
    \subfloat[ضرایب کنترل‌کننده برای کنترل موقعیت]{
        \includegraphics[width=0.48\linewidth]{CH04_PIC/PC.jpg}
    }
    \caption{ضرایب نهایی کنترل‌کننده}
\end{figure}

این تصویر، ضرایب نهایی و تنظیم‌شده برای کنترل‌کننده دو حلقه‌ای آبشاری ($Cascaded$) کوادروتور را نمایش می‌دهد که به دو بخش اصلی تقسیم می‌شود: کنترل‌کننده وضعیت (حلقه داخلی) و کنترل‌کننده موقعیت (حلقه خارجی).

\paragraph{کنترل‌کننده وضعیت (حلقه داخلی):}
شکل (الف) ضرایب \textbf{کنترل‌کننده وضعیت (\lr{Attitude Controller})} را نشان می‌دهد که حلقه کنترلی داخلی و سریع سیستم است. وظیفه این حلقه، پایدارسازی زوایای $Roll$، $Pitch$ و $Yaw$ و همچنین کنترل ارتفاع ($Z$) است. این حلقه فرمان‌های مطلوب خود را از حلقه بیرونی (موقعیت) دریافت کرده و با مقایسه آن با مقادیر واقعی حسگرها، فرمان‌های اصلاحی لازم را تولید می‌کند. همانطور که مشاهده می‌شود، برای هر یک از چهار کانال، یک کنترل‌کننده $PID$ مجزا با بهره‌های (\lr{Kp, Ki, Kd}) متفاوت و تنظیم‌شده به کار رفته است. تفاوت در بهره‌های $Roll$ و $Pitch$ نشان‌دهنده تنظیمات دقیق برای رسیدن به پاسخ دینامیکی مطلوب در هر محور است. استفاده از اشباع انتگرال (\lr{Integral Saturation}) نیز یک تکنیک مهم برای جلوگیری از پدیده انباشت خطا ($windup$) و تضمین پایداری در هنگام اشباع عملگرها است.

\paragraph{کنترل‌کننده موقعیت (حلقه خارجی):}
شکل (ب) ضرایب \textbf{کنترل‌کننده موقعیت (\lr{Position Controller})} را نشان می‌دهد که حلقه کنترلی خارجی و کندتر سیستم است. وظیفه این حلقه، تبدیل خطای سرعت در صفحه‌ی افقی به فرمان‌های زاویه‌ای مطلوب برای حلقه داخلی است. به عبارت دیگر، این کنترل‌کننده تصمیم می‌گیرد که پهپاد برای رسیدن به سرعت مطلوب در راستای محورهای $X$ و $Y$، چقدر باید در محورهای $Roll$ و $Pitch$ خم شود. استفاده از یک کنترل‌کننده $PD$ (بدون جمله انتگرال) در این حلقه، یک انتخاب متداول برای جلوگیری از نوسانات و پاسخ کند در ردیابی سرعت است. نکته بسیار مهم در این بخش، وجود \textbf{محدودیت زاویه (\lr{Attitude Limit})} به میزان ۸ درجه است. این محدودیت به عنوان یک عامل ایمنی و پایداری عمل کرده و اجازه نمی‌دهد که حلقه موقعیت، فرمان‌های زاویه‌ای بیش از حد تهاجمی صادر کند که منجر به از دست رفتن ارتفاع یا ناپایداری پهپاد شود.

\newpage
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{CH04_PIC/Screenshot 2025-09-03 193043.jpg}
    \caption{انیمیشن کوادروتور در مسیر دایره‌ای}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{CH04_PIC/Screenshot 2025-09-03 192233.jpg}
    \caption{انیمیشن کوادروتور در مسیر هشتی}
\end{figure}


\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{CH04_PIC/Screenshot 2025-09-03 194930.jpg}
    \caption{انیمیشن کوادروتور در مسیر لوزی}
\end{figure}

این نمودارها یک ابزار قدرتمند برای درک بصری عملکرد کنترلر هستند. پنل سمت چپ با عنوان $Attitude$، وضعیت لحظه‌ای پهپاد شامل زوایای $Roll$، $Pitch$ و $Yaw$ را در یک چارچوب سه‌بعدی نمایش می‌دهد. پنل سمت راست با عنوان $Position$، مسیر طی شده توسط پهپاد را از لحظه شروع تا زمان فعلی شبیه‌سازی (که در باکس \lr{Time (s)} نمایش داده شده) ترسیم می‌کند. مسیر پرواز از مجموعه‌ای از دایره‌های آبی تشکیل شده که هر کدام، موقعیت پهپاد در یک گام زمانی ثابت را نشان می‌دهند.

دلیل اصلی اینکه فاصله‌ی بین این دایره‌های آبی در طول مسیر متغیر است، به طور مستقیم به سرعت لحظه‌ای کوادروتور مربوط می‌شود. این دایره‌ها در فواصل زمانی ثابتی رسم می‌شوند (که به پارامتر \lr{Frame Rate} بستگی دارد). بنابراین، هرگاه پهپاد با سرعت بالایی در حال حرکت باشد، در یک بازه زمانی ثابت، مسافت بیشتری را طی می‌کند و در نتیجه، فاصله بین دایره‌های متوالی در نمودار زیاد خواهد بود. برعکس، زمانی که پهپاد سرعت خود را کاهش می‌دهد، مسافت کمتری را در همان بازه زمانی طی کرده و فاصله بین دایره‌ها کم و به یکدیگر نزدیک می‌شوند.

این تغییر سرعت، یک ویژگی ذاتی و نشان‌دهنده عملکرد صحیح یک کنترل‌کننده هوشمند است. برای مثال در مسیر هشتی، پهپاد مجبور است در بخش‌های منحنی و به خصوص در نقاط عطف و پیچ‌های تند (مانند مرکز تقاطع و انتهای حلقه‌ها)، سرعت خود را به شدت کاهش دهد تا بتواند با دقت و پایداری تغییر جهت دهد. این کاهش سرعت دقیقاً در نقاطی از نمودار که دایره‌ها به هم فشرده شده‌اند، قابل مشاهده است. در مقابل، در بخش‌های صاف‌تر و طولانی‌تر مسیر، پهپاد شتاب گرفته و با سرعت بیشتری حرکت می‌کند که این امر با افزایش فاصله بین دایره‌ها در نمودار نمایان می‌شود. در نتیجه، این فاصله‌گذاری متغیر یک خطا نیست، بلکه نمایشی بصری از مدیریت هوشمندانه سرعت توسط کنترلر برای ردیابی موفقیت‌آمیز یک مسیر پیچیده و دینامیک است.




\newpage
\section{طراحی کنترل کننده \lr{PID} برای وضعیت}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{CH04_PIC/Quad-attitude.jpg}
    \caption{شماتیک کلی فایل شبیه‌سازی سیمولینک کنترل‌کننده وضعیت کوادروتور}
    \label{x}
\end{figure}

در این بخش، به طراحی و شبیه‌سازی کنترل‌کننده $PID$ برای وضعیت ($Attitude$) کوادروتور پرداخته می‌شود. شماتیک کلی این شبیه‌سازی در شکل \ref{x} نمایش داده شده است. تمرکز بر کنترل وضعیت از آن جهت حائز اهمیت است که آزمون‌های سخت‌افزاری این پروژه بر روی یک دستگاه تست با سه درجه آزادی ($3-DOF$) انجام می‌پذیرد. این دستگاه تنها قابلیت ارزیابی حرکات دورانی (\lr{Roll, Pitch, Yaw}) را فراهم می‌کند و حرکات انتقالی را محدود می‌سازد. بنابراین، هدف اصلی این مرحله، طراحی و اعتبارسنجی یک کنترل‌کننده دقیق و پایدار برای حلقه داخلی کنترل است که مستقیماً در آزمون سخت‌افزاری قابل ارزیابی خواهد بود.

از آنجایی که در بخش‌های پیشین، یک کنترل‌کننده کامل برای موقعیت (\lr{Position Control}) که شامل همین حلقه کنترل وضعیت به عنوان حلقه داخلی بود، با موفقیت طراحی و شبیه‌سازی شده است، این مرحله از پروژه پیچیدگی چندانی ندارد. در واقع، کنترل وضعیت یک زیرمجموعه از مسئله کنترل موقعیت است. در این شبیه‌سازی، دیگر نیازی به حلقه خارجی برای محاسبه زوایای مطلوب از روی خطای موقعیت نیست و فرمان‌های زاویه‌ای به صورت مستقیم به کنترلر اعمال می‌شوند. این ساده‌سازی به ما اجازه می‌دهد تا به طور متمرکز، عملکرد و پاسخ دینامیکی کنترلر وضعیت را به صورت ایزوله تحلیل و تنظیم کنیم.

مطابق با شماتیک، مدل سیمولینک شامل بلوک \lr{Attitude Commands} است که فرمان‌های مرجع برای زوایای $Roll$، $Pitch$ و $Yaw$ را تولید می‌کند. این فرمان‌ها به بلوک \lr{Attitude Controller} وارد می‌شوند که در آن، منطق $PID$ برای هر محور به صورت مجزا پیاده‌سازی شده است. خروجی این کنترلر، گشتاورهای اصلاحی مورد نیاز است که پس از عبور از بلوک \lr{Quadcopter Control Mixing} به فرمان‌های مجزای هر موتور تبدیل می‌شود. در نهایت، این فرمان‌ها به مدل دینامیکی پرنده (\lr{Quadcopter Dynamics}) اعمال شده و پاسخ زاویه‌ای سیستم در خروجی شبیه‌سازی ($simout$) قابل مشاهده است. این چارچوب، بستری ایده‌آل برای تنظیم دقیق بهره‌های کنترلر و اطمینان از عملکرد پایدار آن پیش از پیاده‌سازی روی سخت‌افزار فراهم می‌آورد.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{CH04_PIC/AC_result.png}
    \caption{نتیجه تست کنترل‌کننده وضعیت}
\end{figure}

این آزمون به منظور ارزیابی عملکرد حلقه داخلی کنترل و تنظیم دقیق بهره‌های آن پیش از آزمون‌های پیچیده‌تر ردیابی مسیر طراحی شده است. نتایج کلی نشان می‌دهند که کنترلر طراحی‌شده توانایی پایدارسازی پهپاد و رساندن حالت‌های آن به مقادیر مطلوب را دارد؛ با این حال، پاسخ گذرا (\lr{Transient Response}) در تمام محورها به وضوح نشان‌دهنده یک سیستم زیر میرا ($Underdamped$) است که نیاز به تنظیم دقیق‌تر دارد.

در نمودارهای \lr{Roll Angle Tracking} و \lr{Pitch Angle Tracking}، مشاهده می‌شود که پس از اعمال فرمان پله (به ترتیب ۱۰- و ۱۰+ درجه)، سیستم با موفقیت به مقدار نهایی می‌رسد، اما این فرآیند با یک بیش‌جهش ($Overshoot$) قابل توجه همراه است. به عنوان مثال، در محور $Pitch$، زاویه واقعی تا حدود ۱۲ درجه افزایش یافته و سپس با چندین نوسان، به تدریج حول مقدار مطلوب ۱۰ درجه آرام می‌گیرد. این رفتار نوسانی که زمان نشست (\lr{Settling Time}) آن حدود ۲۵ ثانیه به طول می‌انجامد، نشان‌دهنده بالا بودن نسبی بهره تناسبی ($Kp$) در مقایسه با بهره مشتقی ($Kd$) است که منجر به واکنشی سریع اما ناپایدار می‌شود.

عملکرد کنترلر در محور \lr{Yaw Angle Tracking } ضعف بیشتری را به نمایش می‌گذارد. در پاسخ به فرمان پله ۴۵ درجه، سیستم یک بیش‌جهش بسیار بزرگ، تا حدود ۶۵ درجه، را تجربه می‌کند. نوسانات پس از این فراجهش نیز کند و با دامنه‌ی بزرگ هستند و زمان بسیار طولانی‌تری (حدود ۴۰ ثانیه) برای رسیدن به پایداری نیاز دارند. این پاسخ به شدت زیر میرا، حاکی از تنظیم نبودن دقیق بهره‌های $PID$ برای دینامیک محور $Yaw$ است که معمولاً کندتر از محورهای دیگر است و به میرایی بیشتری نیاز دارد. در مقابل، محور \lr{Altitude Tracking (Z)} بهترین عملکرد را در میان چهار محور از خود نشان می‌دهد؛ فراجهش آن کمتر و زمان نشست آن به طور قابل توجهی سریع‌تر (حدود ۱۰ ثانیه) است، که نشان‌دهنده یک تنظیم موفقیت‌آمیزتر برای کنترل ارتفاع است.

در مجموع، این نتایج ثابت می‌کنند که ساختار کنترلر عملکردی و پایدار است، اما برای دستیابی به یک پاسخ بهینه (سریع و بدون نوسان)، نیاز به تنظیم دقیق‌تر بهره‌ها وجود دارد. به طور مشخص، افزایش بهره مشتقی ($Kd$) برای افزایش میرایی و کاهش بیش‌جهش، و تنظیم مجدد بهره تناسبی ($Kp$) برای رسیدن به تعادل مطلوب بین سرعت پاسخ و پایداری، گام‌های بعدی در فرآیند بهینه‌سازی این کنترلر خواهند بود.

\newpage
\section{طراحی کنترل کننده \lr{Fuzzy-PID} برای وضعیت}
در مراحل اولیه پروژه، یک کنترل‌کننده $PID$ استاندارد با بهره‌های ثابت برای کنترل وضعیت کوادروتور طراحی و شبیه‌سازی شد. نتایج تست این کنترل‌کننده نشان داد که اگرچه سیستم نهایتاً پایدار می‌شود، اما پاسخ گذرای آن دارای نواقص قابل توجهی است. این نواقص شامل 
فراجهش بسیار بزرگ، نوسانات شدید و زمان نشست (\lr{Settling Time}) طولانی بود که نشان‌دهنده یک سیستم زیرمیرای ($Underdamped$) با عملکرد ضعیف است.


این ضعف ذاتی کنترل‌کننده $PID$ با بهره ثابت، که قادر به تطبیق خود با شرایط متغیر پرواز نیست، انگیزه اصلی برای حرکت به سمت یک راهکار هوشمند و تطبیقی بود. در این راستا، معماری $Fuzzy-PID$ انتخاب شد تا با استفاده از منطق فازی، بهره‌های کنترل‌کننده به صورت آنلاین و هوشمند تنظیم شوند و عملکرد دینامیکی سیستم بهبود یابد.


\subsection*{متدولوژی طراحی: از $PID$ دستی تا محدوده دینامیک فازی}

رویکرد اتخاذ شده در این پروژه، یک روش مهندسی عملی و مؤثر برای طراحی سیستم \lr{Fuzzy-PID} است. به جای تعریف محدوده بهره‌ها به صورت کاملاً تجربی، فرآیند در دو مرحله کلیدی انجام شد:

\subsubsection*{تنظیم دستی کنترل‌کننده $PID$ به عنوان نقطه شروع}

ابتدا، یک کنترل‌کننده $PID$ استاندارد برای هر یک از محورهای وضعیت (\lr{Roll, Pitch, Yaw}) به صورت دستی و با دقت تنظیم ($Tune$) شد. هدف از این مرحله، یافتن یک مجموعه بهره بهینه بود که بهترین عملکرد ممکن را با یک کنترل‌کننده خطی ارائه دهد. این بهره‌های بهینه به عنوان \textbf{نقطه مرکزی یا مبنا ($Baseline$)} برای سیستم فازی در نظر گرفته شدند. مقادیر نهایی به دست آمده از این فرآیند به شرح زیر است:
\begin{itemize}
    \item \textbf{محور $Roll$:}
    \begin{itemize}
        \item \texttt{kp\_roll = $2.15$}
        \item \texttt{kd\_roll = $2.5$}
    \end{itemize}
    \item \textbf{محور $Pitch$:}
    \begin{itemize}
        \item \texttt{kp\_pitch = $2.9$}
        \item \texttt{kd\_pitch = $3.1$}
    \end{itemize}
    \item \textbf{محور $Yaw$:}
    \begin{itemize}
        \item \texttt{kp\_yaw = $1$}
        \item \texttt{kd\_yaw = $2.5$}
    \end{itemize}
\end{itemize}

\subsubsection*{تعریف محدوده دینامیک برای تنظیم فازی}

ایده اصلی در این مرحله، تبدیل بهره‌های ثابت به \textbf{محدوده‌های دینامیک} بود. به جای استفاده از یک مقدار ثابت، به سیستم فازی اجازه داده شد تا بهره‌ها را در یک بازه مشخص در اطراف نقطه بهینه دستی، تغییر دهد. این بازه‌ها به صورت درصدی از مقادیر مبنا تعریف شدند:
\begin{itemize}
    \item \textbf{برای محورهای $Roll$ و $Pitch$:} یک محدوده نسبتاً دقیق \textbf{5\% بالاتر و 10\% پایین‌تر} از مقدار بهینه انتخاب شد. این انتخاب نشان می‌دهد که تنظیم دستی برای این دو محور به نقطه بهینه نزدیک بوده و تنها به تنظیمات دقیق و جزئی نیاز دارد.
    \begin{itemize}
        \item \texttt{Kpmin\_roll = $1.935$} | \texttt{Kpmax\_roll = $2.2575$}
        \item \texttt{Kdmin\_roll = $2.25$} | \texttt{Kdmax\_roll = $2.625$}
        \item \texttt{Kpmin\_pitch = $2.61$} | \texttt{Kpmax\_pitch = $3.045$}
        \item \texttt{Kdmin\_pitch = $2.79$} | \texttt{Kdmax\_pitch = $3.255$}
    \end{itemize}
    \item \textbf{برای محور $Yaw$:} با توجه به دینامیک کندتر و پاسخ ضعیف‌تر این محور در حالت $PID$ دستی، یک محدوده وسیع‌تر \textbf{20\% بالاتر و 20\% پایین‌تر} از مقدار بهینه در نظر گرفته شد. این کار به سیستم فازی اجازه می‌دهد تا تطبیق‌پذیری و اصلاحات بزرگ‌تری را برای پایدارسازی این محور اعمال کند.
    \begin{itemize}
        \item \texttt{Kpmin\_yaw = $0.8$} | \texttt{Kpmax\_yaw = $1.2$}
        \item \texttt{Kdmin\_yaw = $2.25$} | \texttt{Kdmax\_yaw = $3.0$}
    \end{itemize}
\end{itemize}
این متدولوژی، پایداری حاصل از یک کنترل‌کننده خوش‌تنظیم را با \textbf{انعطاف‌پذیری و هوشمندی منطق فازی} ترکیب می‌کند.



\section*{توابع عضویت برای ورودی‌ها (خطا و مشتق خطا)}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{CH04_PIC/Screenshot 2025-09-05 103733.jpg}
    \caption{توابع عضویت برای خطا و مشتق خطا}
\end{figure}


این نمودار، نحوه \textbf{فازی‌سازی ($Fuzzification$)} ورودی‌های سیستم را تعریف می‌کند. ورودی‌های این کنترل‌کننده، \textbf{خطای فعلی سیستم ($e(k)$)} و \textbf{تغییرات خطا ($\Delta e(k)$)} هستند.

\begin{itemize}
    \item \textbf{هدف:} هدف این بخش، تبدیل یک مقدار عددی و دقیق (مثلاً خطای $۲.۵$ درجه) به مفاهیم کیفی و زبانی است که برای انسان قابل درک باشد.
    \item \textbf{اجزا:} این نمودار از هفت تابع عضویت \textbf{مثلثی} تشکیل شده است که هر کدام یک مفهوم زبانی را نمایندگی می‌کنند:
    \begin{itemize}
        \item \textbf{$NB$:} منفی بزرگ ($Negative Big$)
        \item \textbf{$NM$:} منفی متوسط ($Negative Medium$)
        \item \textbf{$NS$:} منفی کوچک ($Negative Small$)
        \item \textbf{$ZO$:} تقریباً صفر ($Zero$)
        \item \textbf{$PS$:} مثبت کوچک ($Positive Small$)
        \item \textbf{$PM$:} مثبت متوسط ($Positive Medium$)
        \item \textbf{$PB$:} مثبت بزرگ ($Positive Big$)
    \end{itemize}
    \item \textbf{نحوه کار:} هر مقدار ورودی می‌تواند به یک یا چند مجموعه از این مفاهیم تعلق داشته باشد. برای مثال، یک مقدار خطای کوچک ممکن است 70 درصد به مجموعه "$ZO$" و 30 درصد به مجموعه "$PS$" تعلق داشته باشد. این فرآیند به سیستم اجازه می‌دهد تا با عدم قطعیت کار کرده و استنتاج‌های نرمی انجام دهد.
\end{itemize}


\section*{توابع عضویت برای خروجی‌ها}

\begin{figure}[H]
    \centering
    
    \begin{minipage}{0.48\textwidth}
        \centering
        \includegraphics[width=\linewidth]{CH04_PIC/Screenshot 2025-09-05 103745.jpg}
        \caption{توابع عضویت برای $K_{p}^{\prime}$ و $K_{d}^{\prime}$}
        \label{fig:kp_kd_membership}
    \end{minipage}\hfill % \hfill برای ایجاد فاصله بین دو تصویر
    \begin{minipage}{0.48\textwidth}
        \centering
        \includegraphics[width=\linewidth]{CH04_PIC/Screenshot 2025-09-05 104130.jpg}
        \caption{توابع عضویت برای $\alpha$}
        \label{fig:alpha_membership}
    \end{minipage}
\end{figure}


این دو نمودار، مفاهیم زبانی را به مقادیر عددی و دقیق برای خروجی کنترل‌کننده تبدیل می‌کنند. این فرآیند بخشی از مرحله \textbf{فازی‌زدایی ($Defuzzification$)} است.

\subsubsection*{ توابع عضویت برای بهره‌های $K_{p}^{\prime}$ و $K_{d}^{\prime}$}


این نمودار برای تعیین مقادیر بهره تناسبی ($K'_{p}$) و بهره مشتقی ($K'_{d}$) به کار می‌رود.

\begin{itemize}
    \item \textbf{هدف:} پس از اینکه موتور استنتاج فازی بر اساس قوانین تصمیم گرفت که یک بهره باید «کوچک» یا «بزرگ» باشد، این نمودار مقدار عددی دقیق آن را مشخص می‌کند.
    \item \textbf{اجزا:} این نمودار شامل دو تابع عضویت \textbf{غیرخطی} به نام‌های \textbf{$Small$ (کوچک)} و \textbf{$Big$ (بزرگ)} است. این دو تابع مکمل یکدیگر هستند؛ یعنی در هر نقطه، مجموع درجات عضویت آنها تقریباً برابر یک است.
\end{itemize}

\subsubsection*{ توابع عضویت برای پارامتر $\alpha$}



این نمودار برای تعیین مقدار پارامتر $\alpha$ استفاده می‌شود که برای تنظیم بهره انتگرال به کار می‌رود.

\begin{itemize}
    \item \textbf{هدف:} این نمودار یک روش بسیار ساده و محاسباتی برای تعیین خروجی ارائه می‌دهد.
    \item \textbf{اجزا:} این نمودار از توابع عضویت \textbf{تک‌مقداری ($Singleton$)} تشکیل شده است. در این حالت، هر مفهوم زبانی به یک مقدار عددی واحد و مشخص نگاشت داده می‌شود:
    \begin{itemize}
        \item \textbf{$S$ (کوچک):} مقدار ۲
        \item \textbf{$MS$ (متوسط کوچک):} مقدار ۳
        \item \textbf{$M$ (متوسط):} مقدار ۴
        \item \textbf{$B$ (بزرگ):} مقدار ۵
    \end{itemize}
    \item \textbf{نحوه کار:} اگر قوانین فازی نتیجه بگیرند که $\alpha$ باید "متوسط" باشد، خروجی بدون هیچ محاسبه پیچیده‌ای مستقیماً برابر با \textbf{۴} خواهد بود. این روش به دلیل سادگی و کارایی بالا در سیستم‌های کنترلی بسیار رایج است.
    
\end{itemize}









\section*{جداول قوانین فازی: مغز متفکر کنترل‌کننده}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{CH04_PIC/Gemini_Generated_Image_kiob38kiob38kiob.png}
    \caption{قوانین تنظیم فازی برای $K_{p}^{\prime}$}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{CH04_PIC/Screenshot 2025-09-05 103228.jpg}
    \caption{قوانین تنظیم فازی برای $K_{d}^{\prime}$}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{CH04_PIC/Screenshot 2025-09-05 103410.jpg}
    \caption{قوانین تنظیم فازی برای $\alpha$}
\end{figure}


این سه جدول، در واقع \textbf{دانش و استراتژی یک اپراتور متخصص} را در قالب مجموعه‌ای از قوانین "اگر-آنگاه" پیاده‌سازی می‌کنند. هر خانه از جدول نماینده یک قانون برای یک وضعیت مشخص از سیستم است.

\subsection*{منطق تنظیم بهره تناسبی ($K'_{p}$) و مشتقی ($K'_{d}$)}



این دو جدول یک استراتژی کنترلی مکمل را اجرا می‌کنند:
\begin{itemize}
    \item \textbf{جدول $K'_{p}$:} منطق این جدول \textbf{تهاجمی و سریع} است. هدف اصلی آن، رساندن سریع سیستم به نقطه تنظیم است. به همین دلیل، هرگاه خطا بزرگ باشد (سطرهای $NB$ و $PB$) یا سیستم در حال دور شدن از نقطه تنظیم باشد، بهره تناسبی را \textbf{بزرگ ($B$)} انتخاب می‌کند تا نیروی اصلاحی قوی اعمال شود.
    
    \item \textbf{جدول $K'_{d}$:} منطق این جدول \textbf{پایدارکننده و میراکننده} است. هدف آن جلوگیری از نوسان و فراجهش است. بنابراین، هرگاه سیستم به نقطه تنظیم نزدیک می‌شود (خانه‌های مرکزی جدول)، بهره مشتقی را \textbf{بزرگ ($B$)} انتخاب می‌کند تا مانند یک ترمز عمل کرده و سیستم را آرام کند. برعکس، زمانی که خطا بزرگ است، بهره مشتقی را \textbf{کوچک ($S$)} نگه می‌دارد تا مانع از حرکت سریع اولیه سیستم نشود.
\end{itemize}

این دو جدول با همکاری یکدیگر، تعادلی هوشمند بین \textbf{سرعت پاسخ} و \textbf{پایداری} ایجاد می‌کنند.

\subsection*{منطق تنظیم پارامتر $\alpha$}

این جدول وظیفه مدیریت \textbf{خطای حالت ماندگار} و جلوگیری از \textbf{انباشت خطا (\lr{Integral Windup})} را بر عهده دارد. پارامتر $\alpha$ با زمان انتگرال رابطه معکوس دارد (هرچه $\alpha$ کوچکتر، انتگرال‌گیری قوی‌تر). استراتژی جدول به این صورت است:
\begin{itemize}
    \item \textbf{انتگرال‌گیری قوی (مقدار $\alpha$ کم):} زمانی که خطا وجود دارد اما سیستم تقریباً آرام است (مثلاً $e(k) = NS$ و $\Delta$$e(k)$ = $ZO$)، مقدار $\alpha$ \textbf{کوچک (مثلاً ۲)} است تا هرگونه خطای باقیمانده به سرعت حذف شود.
    \item \textbf{انتگرال‌گیری ضعیف (مقدار $\alpha$ زیاد):} زمانی که خطا صفر است اما سیستم با سرعت در حال حرکت است ($e(k)$ = $ZO$ و $\Delta$$e(k)$ = $NB/PB$)، مقدار $\alpha$ \textbf{بزرگ (۵)} انتخاب می‌شود. این یک حرکت هوشمندانه برای جلوگیری از فراجهش است؛ زیرا از جمع شدن بی‌مورد خطای انتگرال در زمانی که سیستم در حال عبور سریع از نقطه تنظیم است، جلوگیری می‌کند.
\end{itemize}

\section*{فرآیند استنتاج: نحوه اجرای یک قانون}

این نمودار نشان می‌دهد که چگونه \textbf{یک قانون واحد} از جداول بالا در عمل اجرا می‌شود. این فرآیند قلب محاسباتی منطق فازی است:
\begin{enumerate}
    \item \textbf{اندازه‌گیری:} مقادیر عددی و دقیق خطا \texttt{(e)} و تغییرات خطا ($e$)$\Delta$ از سیستم خوانده می‌شوند.
    \item \textbf{تعیین درجه تعلق:} با استفاده از توابع عضویت ورودی، مشخص می‌شود که این مقادیر عددی تا چه حد (با درجه عضویت $\mu$) به مفاهیم زبانی مانند "خطای مثبت کوچک" یا "تغییر خطای صفر" تعلق دارند.
    \item \textbf{محاسبه "قدرت آتش" قانون ($\mu_i$):} درجه‌های تعلق ورودی‌ها با هم ترکیب می‌شوند (معمولاً با عملگر \texttt{AND} که با ضرب یا مینیمم پیاده‌سازی می‌شود). خروجی این مرحله ($\mu_i$) نشان می‌دهد که قانون فعلی تا چه اندازه با وضعیت کنونی سیستم مرتبط است.
    \item \textbf{شکل‌دهی به خروجی:} در نهایت، "قدرت آتش" به دست آمده، خروجی آن قانون را شکل می‌دهد. برای مثال، اگر قدرت یک قانون ۰.۷ باشد و نتیجه آن "بهره بزرگ" باشد، این قانون یک نسخه محدود شده از تابع عضویت "بزرگ" با ارتفاع ۰.۷ را به خروجی نهایی اضافه می‌کند.
\end{enumerate}
در نهایت، خروجی‌های تمام قوانینی که فعال شده‌اند با هم تجمیع شده و به یک فرمان کنترلی واحد تبدیل می‌شوند.






\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{CH04_PIC/Gemini_Generated_Image_19hmkt19hmkt19hm.png}
    \caption{فرآیند استنباط یک قانون فازی}
\end{figure}


\subsection*{معماری و پیاده‌سازی سیستم استنتاج فازی}

سیستم کنترل‌کننده \lr{Fuzzy-PID} طراحی شده بر اساس یک موتور استنتاج فازی (\lr{Fuzzy Inference System}) عمل می‌کند که ساختار آن در گزارش به تفصیل شرح داده شده است.
\begin{itemize}
    \item \textbf{ورودی‌های سیستم:} \textbf{خطای وضعیت ($e(k)$)} و \textbf{تغییرات خطا ($\Delta$$e(k)$)} به عنوان ورودی‌های عددی به سیستم داده می‌شوند.
    
    \item \textbf{موتور استنتاج:} این موتور با استفاده از یک پایگاه دانش شامل \textbf{توابع عضویت} \textbf{پایگاه قوانین اگر-آنگاه ($IF-THEN$)}، ورودی‌ها را پردازش می‌کند.
    \item \textbf{خروجی‌های سیستم:} خروجی موتور فازی، مقادیر بهینه و لحظه‌ای برای بهره‌های نرمال‌شده $K'_{p}$ و $K'_{d}$ و پارامتر $\alpha$ است. این مقادیر سپس به بهره‌های واقعی در محدوده‌های دینامیکی که در بخش قبل تعریف شد، نگاشت داده می‌شوند.
\end{itemize}


\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{CH04_PIC/ACfuzzy_result.png}
    \caption{نتیجه تست کنترل‌کننده وضعیت برای کنترل کننده \lr{PID-Fuzzy}}
\end{figure}
\subsection*{تحلیل نتایج و نتیجه‌گیری}

نتایج شبیه‌سازی کنترل‌کننده \lr{Fuzzy-PID} یک بهبود چشمگیر و بنیادین را نسبت به کنترل‌کننده $PID$ استاندارد نشان می‌دهد.
\begin{itemize}
    \item \textbf{کاهش چشمگیر فراجهش و نوسانات:} پاسخ سیستم در تمام محورها به یک پاسخ \textbf{بهینه و به خوبی میرا شده} تبدیل شده است. فراجهش‌های بزرگ و لرزش‌های طولانی به طور کامل حذف شده‌اند.
    \item \textbf{افزایش سرعت پاسخ:} زمان نشست (\lr{Settling Time}) به شدت کاهش یافته و سیستم با سرعت بسیار بیشتری به مقدار مطلوب خود همگرا می‌شود.
\end{itemize}
این بهبود عملکرد، موفقیت رویکرد اتخاذ شده را اثبات می‌کند. سیستم \lr{Fuzzy-PID} توانست با تنظیم هوشمند و لحظه‌ای بهره‌ها بر اساس شرایط خطا، ضعف‌های کنترل‌کننده خطی را برطرف کرده و یک پاسخ کنترلی سریع، دقیق و پایدار را برای وضعیت کوادروتور فراهم آورد. این استراتژی، بستری قابل اعتماد برای آزمون‌های پیچیده‌تر و پیاده‌سازی نهایی روی سخت‌افزار واقعی ایجاد می‌کند.

\newpage
\section{مقایسه بین \lr{PID} و \lr{Fuzzy-PID}}

\begin{table}[H]
    \centering
    \caption{مقایسه معیارهای عملکرد برای کنترل‌کننده‌های $PID$ و $Fuzzy-PID$}
    \label{tab:performance_comparison}
    \begin{tabular}{l cc cc}
        \toprule
        & \multicolumn{2}{c}{\textbf{\lr{PID}}} & \multicolumn{2}{c}{\textbf{\lr{Fuzzy-PID}}} \\
        \cmidrule(lr){2-3} \cmidrule(lr){4-5}
        \textbf{$Axis$} & \textbf{$MSE$} & \textbf{$ITAE$} & \textbf{$MSE$} & \textbf{$ITAE$} \\
        \midrule
        $Roll$ ($\phi$)    & $2.4780$  & $757.2181$ & $0.2267$ & $21.1218$ \\
        $Pitch$ ($\theta$) & $2.0331$  & $693.7909$ & $0.2003$ & $13.6834$ \\
        $Yaw$ ($\psi$)     & $121.9768$ & $6102.5$   & $48.0384$ & $1413.7$ \\
        \bottomrule
    \end{tabular}
\end{table}

این جدول به مقایسه عملکرد دو نوع کنترل‌کننده مختلف می‌پردازد: \textbf{کنترل‌کننده (\lr{PID})} و \textbf{کنترل‌کننده فازی(\lr{Fuzzy-PID})}. هدف این مقایسه، ارزیابی دقت و کارایی این دو کنترل‌کننده در کنترل یک سیستم با سه محور حرکتی \textbf{$Roll$}، \textbf{$Pitch$} و \textbf{$Yaw$} است.

برای این ارزیابی از دو معیار سنجش خطا استفاده شده است:
\begin{itemize}
    \item \textbf{\lr{ITAE (Integral of Time-weighted Absolute Error)}:} انتگرال زمان در قدرمطلق خطا
    \item \textbf{\lr{MSE (Mean Squared Error):}} میانگین مربعات خطا
\end{itemize}

\subsection*{تحلیل نتایج}

همانطور که در جدول مشاهده می‌شود، مقادیر هر دو معیار خطا ($ITAE$ و $MSE$) برای کنترل‌کننده \textbf{\lr{Fuzzy-PID}} در هر سه محور به طور چشمگیری \textbf{کمتر} از مقادیر مربوط به کنترل‌کننده \textbf{\lr{PID}} است.

\begin{itemize}
    \item \textbf{مقادیر کمتر برای $ITAE$} نشان می‌دهد که کنترل‌کننده \lr{Fuzzy-PID} نه تنها خطای کمتری دارد، بلکه این خطا را در زمان بسیار کوتاه‌تری به صفر نزدیک می‌کند (پاسخ سریع‌تر و میرایی بهتر).
    \item \textbf{مقادیر کمتر برای $MSE$} به این معناست که خطاهای بزرگ و نوسانات شدید در کنترل‌کننده \lr{Fuzzy-PID} بسیار کمتر از نوع استاندارد آن است.
\end{itemize}

\textbf{نتیجه‌گیری کلی از جدول این است که کنترل‌کننده \lr{Fuzzy-PID} عملکرد بسیار بهتری، با دقت بالاتر، سرعت پاسخ سریع‌تر و پایداری بیشتر نسبت به کنترل‌کننده $PID$ استاندارد در این کاربرد خاص از خود نشان داده است.}


\section*{فرمول‌های معیارهای خطا}

در ادامه، فرمول‌های ریاضی برای دو معیار استفاده شده در جدول آورده شده است. در این فرمول‌ها، $e(t)$ نمایانگر تابع خطا (اختلاف بین مقدار مطلوب و مقدار واقعی) در زمان $t$ است.

\subsection*{میانگین مربعات خطا ($MSE$)}

این معیار، میانگین توان دوم خطاها را محاسبه می‌کند. به دلیل وجود توان دوم، این معیار به خطاهای بزرگ حساسیت بیشتری نشان می‌دهد و جریمه سنگین‌تری برای آن‌ها در نظر می‌گیرد. مقدار کمتر $MSE$ به معنای خطاهای کوچکتر و نوسانات کمتر است.
\begin{equation*}
MSE = \frac{1}{T} \int_{0}^{T} [e(t)]^2 dt
\end{equation*}
در فرمول بالا، $T$ بازه زمانی شبیه‌سازی یا عملکرد سیستم است.

\subsection*{انتگرال زمان در قدرمطلق خطا ($ITAE$)}

این معیار، انتگرال قدرمطلق خطا را در زمان ضرب کرده و محاسبه می‌کند. ویژگی مهم $ITAE$ این است که به خطاهایی که برای مدت طولانی باقی می‌مانند، وزن بیشتری می‌دهد. بنابراین، یک کنترل‌کننده با $ITAE$ پایین، سیستمی است که خطای خود را به سرعت حذف می‌کند.



\begin{equation*}
ITAE = \int_{0}^{\infty} t |e(t)| dt
\end{equation*}


\newpage
\chapter{آزمون روی سخت‌افزار واقعی}

\section{معرفی کلی سنسور \lr{MPU-9250}}
سنسور $MPU-9250$ یک واحد اندازه‌گیری اینرسی\LTRfootnote{\lr{Inertial Measurement Unit (IMU)}} توسعه‌یافته توسط شرکت اینون‌سنس\LTRfootnote{\lr{InvenSense (TDK})} است که با ادغام سه نوع حسگر در یک تراشه، در بسیاری از کاربردهای ناوبری و ردیابی حرکتی به‌کار می‌رود. این تراشه دارای نه درجه آزادی ($9-DOF$) است که شامل موارد زیر است:
\begin{itemize}
	\item شتاب‌سنج سه‌محوره\LTRfootnote{$Accelerometer$}
	\item ژیروسکوپ سه‌محوره\LTRfootnote{$Gyroscope$}
	\item مغناطیس‌سنج سه‌محوره\LTRfootnote{$Magnetometer$, $AK8963$}
\end{itemize}
ترکیب این سه حسگر امکان اندازه‌گیری شتاب خطی، نرخ چرخش زاویه‌ای و میدان مغناطیسی زمین را فراهم می‌سازد و اطلاعات جامعی درباره وضعیت حرکتی و جهت‌گیری جسم در فضای سه‌بعدی ارائه می‌دهد.

\section*{مشخصات اصلی}
\subsection*{شتاب‌سنج}
\begin{itemize}
	\item محدوده دینامیکی: $\pm 2g, \pm 4g, \pm 8g, \pm 16g$
	\item دقت خروجی: 16 بیت
	\item حساسیت در حالت $\pm 2g$: معادل 16384 $LSB/g$
\end{itemize}

\subsection*{ژیروسکوپ}
\begin{itemize}
	\item محدوده دینامیکی: $\pm 250, \pm 500, \pm 1000, \pm 2000~^\circ/s$
	\item دقت خروجی: 16 بیت
	\item حساسیت در حالت $\pm 250~^\circ/s$: معادل 131 $LSB/°/s$
\end{itemize}

\subsection*{مغناطیس‌سنج}
\begin{itemize}
	\item محدوده اندازه‌گیری: $\pm 4800~\mu T$
	\item دقت خروجی: 14 یا 16 بیت
	\item حساسیت: حدود $0.6$ $\mu T$/$LSB$
\end{itemize}

\subsection*{سایر مشخصات}
\begin{itemize}
	\item رابط‌های ارتباطی: گذرگاه \lr{I$^2$C}\LTRfootnote{Inter-Integrated Circuit (I$^2$C)} تا 400$kHz$ و \lr{SPI}\LTRfootnote{Serial Peripheral Interface (SPI)} تا 20$MHz$
	\item ولتاژ تغذیه: $2.4$ تا $3.6$ ولت (معمولاً $3.3$ ولت)
	\item دمای کاری: $-40^\circ C$ تا $+85^\circ C$
	\item جریان مصرفی: حدود 3.5 میلی‌آمپر در حالت فعال
\end{itemize}

\section*{اجزای عملکردی}
\subsection*{شتاب‌سنج}
وظیفه شتاب‌سنج، اندازه‌گیری شتاب خطی در راستای سه محور است. با توجه به وجود شتاب گرانش زمین، این حسگر امکان محاسبه زاویه‌های \lr{Roll}\LTRfootnote{Roll} و \lr{Pitch}\LTRfootnote{Pitch} را فراهم می‌کند.

\subsection*{ژیروسکوپ}
ژیروسکوپ نرخ تغییر زاویه حول سه محور را اندازه‌گیری می‌کند. با انتگرال‌گیری از این داده‌ها، تغییر زاویه نسبی محاسبه می‌شود. با این حال، به دلیل خطای تجمعی\LTRfootnote{Drift} لازم است داده‌های ژیروسکوپ با اطلاعات شتاب‌سنج و مغناطیس‌سنج ترکیب گردد.

\subsection*{مغناطیس‌سنج}
مغناطیس‌سنج میدان مغناطیسی محیط را حس می‌کند و برای تعیین جهت شمال مغناطیسی به‌کار می‌رود. این خروجی مرجع مطلق برای زاویه \lr{Yaw}\LTRfootnote{Yaw} محسوب می‌شود.

\section*{ترکیب داده‌ها}
به منظور دستیابی به برآورد پایدار و دقیق از وضعیت و جهت‌گیری سه‌بعدی، داده‌های سه حسگر ترکیب می‌شوند. این فرآیند با عنوان «ترکیب داده‌ها»\LTRfootnote{Sensor Fusion} شناخته می‌شود.

\begin{itemize}
	\item شتاب‌سنج + ژیروسکوپ $\rightarrow$ تثبیت $Roll$ و $Pitch$
	\item ژیروسکوپ + مغناطیس‌سنج $\rightarrow$ تثبیت $Yaw$
\end{itemize}

الگوریتم‌های متداول در این حوزه شامل موارد زیر هستند:
\begin{itemize}
	\item فیلتر مکمل\LTRfootnote{Complementary Filter}
	\item فیلتر ماهونی\LTRfootnote{Mahony Filter}
	\item فیلتر مدگوییک\LTRfootnote{Madgwick Filter}
	\item فیلتر کالمن\LTRfootnote{Kalman Filter}
\end{itemize}


\section*{فیلتر مکمل}
فیلتر مکمل\LTRfootnote{Complementary Filter} یکی از ساده‌ترین روش‌ها برای ترکیب داده‌های شتاب‌سنج و ژیروسکوپ است. ایده اصلی این فیلتر بر این اساس است که ژیروسکوپ در کوتاه‌مدت دقیق ولی در بلندمدت دچار رانش می‌شود، در حالی که شتاب‌سنج در بلندمدت دقیق اما در کوتاه‌مدت نویزی است. بنابراین با ترکیب وزنی این دو منبع داده، زوایای پایدار و نسبتاً دقیق محاسبه می‌شوند.

معادله کلی فیلتر مکمل به شکل زیر است:
\[
\theta(t) = \alpha \left( \theta(t - 1) + \dot{\theta}_{gyro} \cdot \Delta t \right) \;+\; (1-\alpha)\,\theta_{acc}
\]
که در آن \(\theta\) زاویه تخمینی، \(\dot{\theta}_{gyro}\) نرخ زاویه‌ای ژیروسکوپ و \(\theta_{acc}\) زاویه محاسبه‌شده از شتاب‌سنج است. ضریب \(\alpha\) معمولاً بین $0.98$ تا $0.99$ انتخاب می‌شود.

\section*{فیلتر ماهونی}
فیلتر ماهونی\LTRfootnote{Mahony Filter} یکی از الگوریتم‌های رایج در ترکیب داده‌های حسگرهای اینرسی است که به‌ویژه برای سنسورهای ۹ درجه آزادی (شتاب‌سنج، ژیروسکوپ و مغناطیس‌سنج) به‌کار می‌رود. اساس این فیلتر بر استفاده از کنترل‌کننده تناسبی–انتگرالی\LTRfootnote{Proportional–Integral (PI) Controller} برای کاهش خطای ژیروسکوپ است. در این روش، جهت‌گیری جسم به‌صورت یک کواترنیون\LTRfootnote{Quaternion} نمایش داده می‌شود. کواترنیون یک نمایش ریاضی از دوران سه‌بعدی است که نسبت به زاویه‌های اویلر پایدارتر بوده و مشکل قفل گیمبال\LTRfootnote{Gimbal Lock} در آن رخ نمی‌دهد.

ایده اصلی فیلتر به این صورت است: ابتدا نرخ زاویه‌ای از ژیروسکوپ خوانده می‌شود و برای به‌روزرسانی وضعیت جسم به‌کار می‌رود. سپس بردارهای مرجع (مانند شتاب جاذبه یا میدان مغناطیسی زمین) با بردارهای اندازه‌گیری‌شده مقایسه می‌شوند و اختلاف آن‌ها به‌عنوان یک خطا محاسبه می‌گردد. این خطا در یک حلقه تناسبی–انتگرالی اعمال می‌شود و نرخ زاویه‌ای اصلاح‌شده به‌دست می‌آید. با استفاده از این نرخ اصلاح‌شده، کواترنیون وضعیت جسم به‌روزرسانی می‌شود.

معادله کلی این فیلتر به صورت زیر بیان می‌شود:
\[
\dot{q} = \tfrac{1}{2} q \otimes \omega_{corr}
\]

که در آن \(q\) کواترنیون وضعیت و \(\otimes\) ضرب کواترنیون است. نرخ زاویه‌ای اصلاح‌شده نیز از رابطه زیر به‌دست می‌آید:
\[
\omega_{corr} = \omega_{gyro} + K_p e + K_i \int e \, dt
\]

در این رابطه:
\begin{itemize}
	\item \(\omega_{gyro}\): نرخ زاویه‌ای خام ژیروسکوپ
	\item \(e\): خطای ناشی از اختلاف بردارهای اندازه‌گیری‌شده و بردارهای مرجع
	\item \(K_p, K_i\): ضرایب تناسبی و انتگرالی برای تنظیم دقت و پایداری
\end{itemize}

خروجی نهایی فیلتر ماهونی معمولاً به‌صورت زاویه‌های اویلر \lr{Yaw}، \lr{Pitch} و \lr{Roll} ارائه می‌شود و در مقایسه با روش‌های ساده‌تر (مانند فیلتر مکمل) پایداری و دقت بیشتری دارد، در حالی که از نظر محاسباتی سبک‌تر از فیلتر کالمن است.


\section*{فیلتر مدگوییک}
فیلتر مدگوییک\LTRfootnote{Madgwick Filter} یکی از روش‌های محبوب برای ترکیب داده‌های حسگرهای اینرسی است که به دلیل سرعت همگرایی بالا و دقت مناسب در بسیاری از پروژه‌های عملی استفاده می‌شود. ایده اصلی این فیلتر بر پایه‌ی یک بهینه‌سازی ریاضی قرار دارد. در این الگوریتم، وضعیت جسم به صورت یک کواترنیون نمایش داده می‌شود و یک تابع خطا تعریف می‌شود که نشان‌دهنده اختلاف بین بردارهای حسگر (شتاب‌سنج و مغناطیس‌سنج) و بردارهای پیش‌بینی‌شده بر اساس کواترنیون است.

برای به حداقل رساندن این خطا، فیلتر مدگوییک از روش گرادیان نزولی\LTRfootnote{Gradient Descent} استفاده می‌کند. ایده این روش این است که اگر تابع خطا \(f(q)\) داشته باشیم، جهت گرادیان \(\nabla f(q)\) جهتی است که سریع‌ترین افزایش مقدار خطا را نشان می‌دهد. بنابراین با حرکت در خلاف جهت گرادیان، مقدار خطا کاهش می‌یابد. فیلتر مدگوییک با استفاده از این اصل، در هر مرحله تخمینی از گرادیان خطا را محاسبه کرده و یک تصحیح کوچک به نرخ زاویه‌ای ژیروسکوپ اعمال می‌کند.

معادله کلی به‌روزرسانی کواترنیون در این فیلتر به صورت زیر است:
\[
\dot{q} = \tfrac{1}{2} q \otimes \omega_{gyro} - \beta \frac{\nabla f(q, a, m)}{\|\nabla f(q, a, m)\|}
\]

در این رابطه:
\begin{itemize}
	\item \(q\): کواترنیون وضعیت
	\item \(\omega_{gyro}\): نرخ زاویه‌ای ژیروسکوپ
	\item \(a, m\): بردارهای شتاب‌سنج و مغناطیس‌سنج
	\item \(\nabla f(q,a,m)\): گرادیان تابع خطا
	\item \(\beta\): ضریب همگرایی که سرعت اصلاح خطا را کنترل می‌کند
\end{itemize}

مزیت اصلی این روش آن است که حتی با نرخ نمونه‌برداری پایین (مثلاً $50Hz$) نیز به سرعت همگرا می‌شود و رانش ژیروسکوپ را به‌خوبی کاهش می‌دهد. به همین دلیل، فیلتر مدگوییک انتخابی مناسب برای کاربردهای رباتیک سبک و دستگاه‌های پوشیدنی محسوب می‌شود.


\section*{فیلتر کالمن}
فیلتر کالمن\LTRfootnote{Kalman Filter} یک الگوریتم پیشرفته تخمین حالت است که بر پایه مدل دینامیکی سیستم و داده‌های اندازه‌گیری نویزی عمل می‌کند. این فیلتر در دو مرحله اجرا می‌شود: مرحله پیش‌بینی\LTRfootnote{Prediction} و مرحله به‌روزرسانی\LTRfootnote{Update}. در مرحله پیش‌بینی، حالت بعدی بر اساس مدل دینامیکی تخمین زده می‌شود. در مرحله به‌روزرسانی، داده‌های حسگر وارد شده و تخمین اصلاح می‌گردد.

معادلات کلی فیلتر کالمن عبارت‌اند از:
\[
\hat{x}_{k|k-1} = F \hat{x}_{k-1|k-1} + B u_k
\]
\[
P_{k|k-1} = F P_{k-1|k-1} F^T + Q
\]
\[
K_k = P_{k|k-1} H^T (H P_{k|k-1} H^T + R)^{-1}
\]
\[
\hat{x}_{k|k} = \hat{x}_{k|k-1} + K_k (z_k - H \hat{x}_{k|k-1})
\]
\[
P_{k|k} = (I - K_k H) P_{k|k-1}
\]
که در آن \(x\) بردار حالت، \(F\) ماتریس انتقال، \(Q\) کوواریانس نویز فرایند، \(R\) کوواریانس نویز اندازه‌گیری، \(H\) ماتریس مشاهده و \(K\) بهره کالمن است. این فیلتر با وجود دقت بالا، از نظر محاسباتی سنگین‌تر از سایر روش‌هاست.


\section{شرح کد \lr{MPU-9250}}

سنسور \lr{MPU-9250} به عنوان قلب سیستم ادراک در این پروژه عمل می‌کند. این واحد اندازه‌گیری اینرسی (\lr{IMU}) وظیفه ارائه اطلاعات دقیق و لحظه‌ای از وضعیت زاویه‌ای کوادروتور را بر عهده دارد تا کنترل‌کننده بتواند تصمیمات اصلاحی صحیحی اتخاذ نماید. کد درایور این سنسور از دو فایل اصلی تشکیل شده است: فایل سرآیند (\lr{mpu9250.h}) که ساختارها و توابع عمومی را تعریف می‌کند و فایل منبع (\lr{mpu9250.c}) که منطق اصلی پیاده‌سازی را در خود جای داده است.

\subsection{فایل سرآیند (\lr{mpu9250.h})}

این فایل به عنوان \textbf{واسط عمومی (\lr{Public Interface})} کتابخانه عمل می‌کند و تعاریف کلیدی مورد نیاز برای استفاده از درایور را فراهم می‌آورد.

\subsubsection{ساختارهای داده (\lr{Data Structures})}
\begin{itemize}
    \item \lr{MPU9250\_t}: این ساختار اصلی، تمامی داده‌های مرتبط با سنسور را در خود تجمیع می‌کند. این داده‌ها شامل مقادیر \textbf{خام ۱۶ بیتی} از شتاب‌سنج و ژیروسکوپ، مقادیر \textbf{تبدیل‌شده به واحدهای فیزیکی} (\lr{g} برای شتاب و \lr{dps} برای سرعت زاویه‌ای)، دمای سنسور، و مهم‌تر از همه، \textbf{خروجی‌های نهایی فیلتر شده} یعنی زوایای \lr{Pitch}، \lr{Roll} و \lr{Yaw} است. یک فیلد \lr{Gz\_offset} نیز برای نگهداری خطای بایاس کالیبره‌شده ژیروسکوپ محور \lr{Z} در نظر گرفته شده است.

    \item \lr{Kalman\_t}: این ساختار تمامی پارامترها و متغیرهای حالت مورد نیاز برای یک نمونه از \textbf{فیلتر کالمن} را تعریف می‌کند. این پارامترها شامل ماتریس‌های کوواریانس نویز (\lr{Q\_angle}, \lr{Q\_bias}, \lr{R\_measure}) برای تنظیم فیلتر، و متغیرهای حالت (\lr{angle}, \lr{bias}) هستند که توسط فیلتر تخمین زده می‌شوند.
\end{itemize}

\subsubsection{اعلان توابع (\lr{Function Prototypes})}
در این بخش، توابع عمومی که از خارج این فایل قابل فراخوانی هستند، اعلان شده‌اند. این توابع عبارتند از:
\begin{itemize}
    \item \lr{MPU9250\_Init}: برای راه‌اندازی اولیه و پیکربندی سنسور.
    \item \lr{MPU9250\_Read\_Accel} و \lr{MPU9250\_Read\_Gyro}: برای خواندن داده‌های خام از هر سنسور به صورت مجزا.
    \item \lr{MPU9250\_Calibrate\_Gyro}: برای اجرای روتین کالیبراسیون ژیروسکوپ.
    \item \lr{MPU9250\_Read\_All}: تابع اصلی که تمام داده‌های سنسور را خوانده، فیلتر کالمن را اجرا کرده و زوایای نهایی را محاسبه می‌کند.
    \item \lr{Kalman\_getAngle}: پیاده‌سازی الگوریتم فیلتر کالمن.
\end{itemize}

\subsection{فایل منبع (\lr{mpu9250.c})}

این فایل شامل پیاده‌سازی و منطق اصلی توابع اعلان‌شده در فایل سرآیند است.

\subsubsection{\lr{MPU9250\_Init()}}
این تابع وظیفه آماده‌سازی سنسور برای کار را بر عهده دارد.
\begin{enumerate}
    \item \textbf{بررسی شناسه دستگاه:} ابتدا با خواندن رجیستر \lr{WHO\_AM\_I}، از وجود و صحت ارتباط با سنسور اطمینان حاصل می‌شود.

    \item \textbf{فعال‌سازی:} سنسور با نوشتن مقدار صفر در رجیستر مدیریت توان (\lr{PWR\_MGMT\_1\_REG}) از حالت خواب بیدار می‌شود.

    \item \textbf{پیکربندی:} نرخ نمونه‌برداری، و محدوده‌های اندازه‌گیری شتاب‌سنج (\lr{g ±2}) و ژیروسکوپ (\lr{dps ±250}) تنظیم می‌شوند. این مقادیر حساسیت حداکثری را برای سیستم فراهم می‌کنند.
\end{enumerate}

\subsubsection{\lr{MPU9250\_Read\_Accel()} و \lr{MPU9250\_Read\_Gyro()}}
این توابع ۶ بایت داده خام را از طریق \lr{I2C} از رجیسترهای مربوطه می‌خوانند. سپس داده‌های خام ۱۶ بیتی را با تقسیم بر \textbf{ضریب حساسیت (\lr{Scale Factor})} به واحدهای فیزیکی استاندارد تبدیل می‌کنند (\lr{16384.0} برای شتاب‌سنج و \lr{131.0} برای ژیروسکوپ که متناسب با محدوده‌های تنظیم‌شده در تابع \lr{Init} است).

\subsubsection{\lr{MPU9250\_Calibrate\_Gyro()}}
این تابع با دریافت تعداد مشخصی نمونه از ژیروسکوپ محور \lr{Z} در حالت سکون و محاسبه میانگین آن‌ها، \textbf{خطای بایاس (\lr{Gz\_offset})} را به دست می‌آورد. این مقدار برای محاسبه دقیق‌تر زاویه \lr{Yaw} ضروری است.

\subsubsection{\lr{MPU9250\_Read\_All()}}
این تابع اصلی‌ترین بخش درایور است و در هر بار فراخوانی، یک چرخه کامل از خواندن تا پردازش را انجام می‌دهد:
\begin{enumerate}
    \item \textbf{خواندن یکپارچه:} ۱۴ بایت داده مربوط به شتاب‌سنج، دما و ژیروسکوپ را در یک تراکنش \lr{I2C} می‌خواند تا سرعت و کارایی افزایش یابد.

    \item \textbf{تبدیل واحد:} داده‌های خام را به واحدهای فیزیکی تبدیل می‌کند.

    \item \textbf{محاسبه زوایای خام:} با استفاده از داده‌های شتاب‌سنج، یک تخمین اولیه از زوایای \lr{Roll} و \lr{Pitch} از طریق روابط مثلثاتی (\lr{atan} و \lr{atan2}) محاسبه می‌شود. این تخمین در بلندمدت دقیق اما در کوتاه‌مدت به نویز حساس است.

    \item \textbf{اجرای فیلتر کالمن:} برای هر یک از زوایای \lr{Roll} و \lr{Pitch}، تابع \lr{Kalman\_getAngle} فراخوانی می‌شود. این فیلتر، \textbf{تخمین زاویه‌ای مبتنی بر شتاب‌سنج} (که پایدار اما نویزی است) را با \textbf{داده‌های سرعت زاویه‌ای ژیروسکوپ} (که در کوتاه‌مدت دقیق اما در بلندمدت دچار دریفت می‌شود) ترکیب کرده و یک خروجی بهینه، پایدار و با پاسخ سریع تولید می‌کند.

    \item \textbf{محاسبه زاویه \lr{Yaw}:} زاویه \lr{Yaw} از طریق \textbf{انتگرال‌گیری} از سرعت زاویه‌ای کالیبره‌شده (\lr{Gz - Gz\_offset}) در طول زمان (\lr{dt}) محاسبه می‌شود. این روش یک تخمین نسبی از جهت‌گیری ارائه می‌دهد که در طول زمان دچار دریفت خواهد شد، اما برای آزمون‌های کوتاه در سکوی تست کافی است.
\end{enumerate}

\subsubsection{\lr{Kalman\_getAngle()}}
این تابع، الگوریتم فیلتر کالمن یک‌بعدی را پیاده‌سازی می‌کند. عملکرد آن در دو مرحله خلاصه می‌شود:
\begin{enumerate}
    \item \textbf{مرحله پیش‌بینی (\lr{Prediction}):} حالت بعدی زاویه بر اساس مقدار قبلی و سرعت زاویه‌ای ژیروسکوپ پیش‌بینی می‌شود.

    \item \textbf{مرحله به‌روزرسانی (\lr{Update}):} خطای بین مقدار پیش‌بینی‌شده و مقدار اندازه‌گیری‌شده توسط شتاب‌سنج محاسبه می‌شود. سپس فیلتر با استفاده از \textbf{بهره کالمن (\lr{Kalman Gain})}، حالت خود (زاویه و بایاس ژیروسکوپ) را اصلاح می‌کند تا به تخمین بهینه‌تری دست یابد.
\end{enumerate}



\section{شرح کد \lr{basic}}

این ماژول، پایه‌ای‌ترین و حیاتی‌ترین بخش نرم‌افزار کنترل‌کننده پرواز را تشکیل می‌دهد. وظیفه اصلی آن فراهم آوردن یک \textbf{بستر زمانی دقیق (\lr{Timing Foundation})} برای کل سیستم و مدیریت متغیرهای سراسری وضعیت پرواز است. بدون یک زمان‌بندی دقیق، اجرای صحیح الگوریتم‌های کنترل، خواندن منظم داده‌های سنسور و عملکرد پایدار سیستم غیرممکن خواهد بود. این ماژول نیز از دو فایل سرآیند و منبع تشکیل شده است.

\subsection{فایل سرآیند (\lr{basic.h})}

این فایل، تعاریف عمومی و متغیرهای سراسری را که باید در سایر بخش‌های پروژه قابل دسترسی باشند، مشخص می‌کند.

\begin{itemize}
    \item \textbf{کتابخانه‌ها و تعاریف اولیه:} این فایل کتابخانه‌های استاندارد \lr{STM32 HAL} مانند \lr{main.h} و \lr{tim.h} را فراخوانی می‌کند. همچنین تایمر \lr{TIM2} به عنوان منبع زمان‌سنج سیستم با نام \lr{SYSTICK\_TIMER} تعریف شده است.

    \item \textbf{متغیرهای خارجی (\lr{extern}):}
        \begin{itemize}
            \item \lr{us\_systick} و \lr{ms\_systick}: این دو متغیر برای نگهداری زمان سیستم به ترتیب با دقت میکروثانیه و میلی‌ثانیه تعریف شده‌اند و در سراسر پروژه قابل دسترسی هستند.
            \item \lr{Roll}, \lr{Pitch}, \lr{Yaw}, \lr{Altitude}: این متغیرهای سراسری، آخرین مقادیر محاسبه‌شده برای وضعیت و ارتفاع کوادروتور را نگهداری می‌کنند. با تعریف آن‌ها به صورت \lr{extern}، ماژول‌های دیگر (مانند کنترل‌کننده یا فرستنده تله‌متری) می‌توانند به راحتی به این داده‌های کلیدی دسترسی داشته باشند.
        \end{itemize}

    \item \textbf{اعلان توابع (\lr{Function Prototypes}):}
        \begin{itemize}
            \item \lr{module\_00\_basic\_init}: تابع راه‌اندازی اولیه ماژول.
            \item \lr{module\_00\_basic\_loop\_handler}: تابعی که در حلقه اصلی برنامه برای به‌روزرسانی زمان فراخوانی می‌شود.
            \item \lr{module\_00\_basic\_tim\_interrupt\_handler}: تابع مدیریت وقفه‌های تایمر.
            \item \lr{getSystickIn\_us} و \lr{getSystickIn\_ms}: توابعی برای دریافت زمان فعلی سیستم با دقت‌های مختلف.
        \end{itemize}
\end{itemize}

\subsection{فایل منبع (\lr{basic.c})}

این فایل، منطق اصلی مربوط به پیاده‌سازی زمان‌سنج دقیق سیستم را در خود دارد.

\subsubsection{متغیرها}
متغیرهای سراسری مربوط به زمان در این فایل مقداردهی اولیه می‌شوند. متغیر \lr{us\_dt} نیز برای محاسبه و نگهداری فاصله زمانی بین هر بار اجرای حلقه اصلی برنامه تعریف شده است که برای الگوریتم‌های انتگرال‌گیر و مشتق‌گیر در کنترل‌کننده بسیار حیاتی است.

\subsubsection{\lr{module\_00\_basic\_init()}}
این تابع، تایمر \lr{TIM2} را در حالت وقفه ($Interrupt$) فعال کرده و شمارنده آن را صفر می‌کند. از این لحظه به بعد، تایمر شروع به شمارش می‌کند و با هر بار سرریز شدن ($overflow$)، یک وقفه ایجاد می‌نماید.

\subsubsection{ساختار زمان‌سنج ۶۴ بیتی}
از آنجایی که تایمرهای \lr{STM32} معمولاً ۱۶ یا ۳۲ بیتی هستند، برای جلوگیری از سرریز شدن شمارنده در مدت زمان کوتاه، یک زمان‌سنج ۶۴ بیتی با دقت میکروثانیه به صورت نرم‌افزاری پیاده‌سازی شده است:
\begin{itemize}
    \item \textbf{\lr{module\_00\_basic\_tim\_interrupt\_handler()}}: این تابع در پاسخ به وقفه سرریز تایمر \lr{TIM2} اجرا می‌شود. با هر بار اجرا، متغیر \lr{us\_period\_overflow} یک واحد افزایش می‌یابد. این متغیر تعداد دفعاتی که شمارنده ۳۲ بیتی سرریز شده است را ثبت می‌کند.
    \item \textbf{\lr{getSystickIn\_us()}}: این تابع زمان دقیق سیستم را با ترکیب مقدار فعلی شمارنده تایمر (\lr{htim2.Instance->CNT} که بخش کم‌ارزش ۳۲ بیتی است) و تعداد سرریزها (\lr{us\_period\_overflow} که بخش پراارزش ۳۲ بیتی است) محاسبه می‌کند. این کار از طریق عملیات شیفت بیتی انجام شده و یک شمارنده یکپارچه ۶۴ بیتی با دقت میکروثانیه را شبیه‌سازی می‌کند.
\end{itemize}

\subsubsection{\lr{module\_00\_basic\_loop\_handler()}}
این تابع در هر تکرار از حلقه اصلی برنامه (\lr{main loop}) فراخوانی می‌شود. وظیفه اصلی آن محاسبه دقیق فاصله زمانی بین اجرای فعلی و قبلی حلقه است. این مقدار که در متغیر \lr{us\_dt} ذخیره می‌شود، همان پارامتر \(\Delta t\) است که در معادلات دیفرانسیل کنترل‌کننده برای انتگرال‌گیری از خطا و محاسبه مشتق آن به کار می‌رود و دقت آن تأثیر مستقیمی بر پایداری و عملکرد سیستم کنترلی دارد.



\section{شرح کد \lr{controller}}

این ماژول، مغز متفکر سیستم کنترل پرواز است. وظیفه اصلی آن، پیاده‌سازی الگوریتم‌های کنترل حلقه بسته برای پایدارسازی وضعیت کوادروتور، ترکیب خروجی‌های کنترلی (\lr{Motor Mixing}) و ارسال فرمان نهایی به موتورها از طریق سیگنال \lr{PWM} است. این بخش بر اساس داده‌های وضعیت دریافتی از ماژول \lr{basic} و سنسور \lr{MPU-9250}، تصمیمات اصلاحی لازم را اتخاذ می‌کند.

\subsection{فایل سرآیند (\lr{controller.h})}

این فایل، ساختار داده اصلی و توابع عمومی ماژول کنترل‌کننده را تعریف می‌کند.

\begin{itemize}
    \item \textbf{وابستگی‌ها:} این فایل با فراخوانی \lr{basic.h}، به متغیرهای سراسری وضعیت پرواز (\lr{Roll}, \lr{Pitch}, \lr{Yaw}) و توابع زمان‌بندی دقیق دسترسی پیدا می‌کند.

    \item \textbf{ساختار داده \lr{ControlParam}:} این ساختار به صورت یک قالب عمومی برای نگهداری تمام اطلاعات و پارامترهای یک حلقه کنترل \lr{PID} طراحی شده است. اعضای کلیدی آن عبارتند از:
    \begin{itemize}
        \item \lr{kp, ki, kd}: بهره‌های تناسبی، انتگرالی و مشتقی کنترل‌کننده.
        \item \lr{p\_max\_limit, i\_max\_limit, d\_max\_limit}: محدودیت‌های جداگانه برای هر یک از جملات \lr{P}، \lr{I} و \lr{D}. این قابلیت، یک روش پیشرفته برای جلوگیری از پدیده \textbf{بادشدگی انتگرال (\lr{Integral Windup})} و اشباع ناخواسته هر بخش از کنترل‌کننده است.
        \item \lr{set\_point}: مقدار مطلوب یا نقطه تنظیم که کنترل‌کننده باید به آن برسد.
        \item \lr{point}: مقدار واقعی و اندازه‌گیری‌شده از سیستم (مثلاً زاویه \lr{Roll} فعلی).
        \item \lr{error}, \lr{last\_error}, \lr{d\_error}: متغیرهای حالت برای محاسبه خطای فعلی، خطای قبلی و مشتق فیلترشده خطا.
        \item \lr{control\_effort}: خروجی نهایی و ترکیبی کنترل‌کننده که به بخش ترکیب موتورها ارسال می‌شود.
    \end{itemize}

    \item \textbf{اعلان توابع:} توابع عمومی \lr{module\_01\_controller\_init} برای راه‌اندازی و \lr{module\_01\_controller\_loop\_handler} برای اجرا در حلقه اصلی برنامه، در این بخش اعلان شده‌اند.
\end{itemize}

\subsection{فایل منبع (\lr{controller.c})}

این فایل شامل پیاده‌سازی منطق کنترل و الگوریتم‌های مربوطه است.

\subsubsection{راه‌اندازی کنترل‌کننده‌ها}
در ابتدای فایل، چهار نمونه از ساختار \lr{ControlParam} برای هر یک از محورهای کنترلی (\lr{Roll}, \lr{Pitch}, \lr{Yaw}, \lr{Altitude}) ایجاد و با بهره‌های اولیه مقداردهی می‌شوند. متغیرهای سراسری برای فعال‌سازی هر کنترل‌کننده (\lr{Roll\_enable}, \lr{Pitch\_enable}) و فعال‌سازی کلی موتورها (\lr{all\_enable}) نیز به عنوان یک ویژگی ایمنی و آزمون تعریف شده‌اند.

\subsubsection{\lr{module\_01\_controller\_init()}}
این تابع، تایمر \lr{TIM3} را برای تولید سیگنال \lr{PWM} بر روی هر چهار کانال راه‌اندازی می‌کند. این کانال‌ها مستقیماً به اسپیدکنترلرهای چهار موتور متصل می‌شوند و وظیفه کنترل سرعت آن‌ها را بر عهده دارند.

\subsubsection{\lr{module\_01\_controller\_loop\_handler()}}
این تابع، حلقه اصلی کنترل است که با فرکانس ثابت اجرا می‌شود.
\begin{itemize}
    \item \textbf{زمان‌بندی حلقه:} کد تنها در صورتی اجرا می‌شود که بیش از ۱۰۰۰۰ میکروثانیه (۱۰ میلی‌ثانیه) از آخرین اجرا گذشته باشد. این ساختار یک حلقه کنترل با فرکانس ثابت \textbf{۱۰۰ هرتز} ایجاد می‌کند که برای عملکرد پایدار کنترل‌کننده‌های دیجیتال ضروری است.
    \item \textbf{اجرای کنترل‌کننده‌ها:} در هر تکرار، مقادیر فعلی \lr{Roll}، \lr{Pitch} و \lr{Yaw} از متغیرهای سراسری خوانده شده و به عنوان ورودی به تابع عمومی \lr{pidController} ارسال می‌شوند. فاصله زمانی دقیق حلقه (\lr{dt}) نیز محاسبه و به این تابع داده می‌شود.
    \item \textbf{الگوریتم ترکیب موتورها (\lr{Motor Mixing}):} پس از محاسبه خروجی (\lr{control\_effort}) هر یک از چهار کنترل‌کننده، این مقادیر بر اساس یک ماتریس ترکیب استاندارد با یکدیگر جمع و تفریق می‌شوند تا مقدار نیروی لازم برای هر موتور (\lr{mx1} تا \lr{mx4}) مشخص گردد. این الگوریتم برای یک کوادروتور با پیکربندی \lr{X} به شکل زیر است:
    \[
    \begin{bmatrix}
        m_1 \\
        m_2 \\
        m_3 \\
        m_4
    \end{bmatrix}
    =
    \begin{bmatrix}
        \text{$Thrust$} - \text{$Pitch$}_{\text{$effort$}} - \text{$Roll$}_{\text{$effort$}} - \text{$Yaw$}_{\text{$effort$}} \\
        \text{$Thrust$} - \text{$Pitch$}_{\text{$effort$}} + \text{$Roll$}_{\text{$effort$}} + \text{$Yaw$}_{\text{$effort$}} \\
        \text{$Thrust$} + \text{$Pitch$}_{\text{$effort$}} + \text{$Roll$}_{\text{$effort$}} - \text{$Yaw$}_{\text{$effort$}} \\
        \text{$Thrust$} + \text{$Pitch$}_{\text{$effort$}} - \text{$Roll$}_{\text{$effort$}} + \text{$Yaw$}_{\text{$effort$}}
    \end{bmatrix}
    \]
    \item \textbf{ارسال فرمان به موتورها:} در نهایت، مقادیر محاسبه‌شده برای هر موتور پس از عبور از یک تابع محدودکننده، به رجیسترهای \lr{Capture/Compare} تایمر \lr{TIM3} اعمال می‌شوند. یک مقدار پایه \lr{150} نیز به خروجی اضافه می‌شود که به عنوان حداقل مقدار \lr{PWM} برای روشن ماندن موتورها عمل می‌کند.
\end{itemize}

\subsubsection{پیاده‌سازی الگوریتم \lr{pidController()}}
این تابع یک پیاده‌سازی عمومی و مقاوم از الگوریتم \lr{PID} را ارائه می‌دهد.
\begin{itemize}
    \item \textbf{جمله مشتق فیلترشده:} به جای محاسبه مستقیم مشتق خطا که به نویز سنسور بسیار حساس است، از یک \textbf{فیلتر پایین‌گذر} ساده بر روی تفاضل خطاها استفاده شده است:
    \lr{d\_error = d\_error + (delta\_error - d\_error) * 0.2}.
    این کار اثر نویز را به شدت کاهش داده و اجازه می‌دهد از بهره مشتقی (\lr{Kd}) بالاتری برای میرایی نوسانات استفاده شود.
    \item \textbf{محدودیت ضد بادشدگی (\lr{Anti-Windup}):} پس از محاسبه هر یک از جملات \lr{P}، \lr{I} و \lr{D}، مقدار آن‌ها در محدوده تعریف‌شده در ساختار \lr{ControlParam} محدود ($clamped$) می‌شود. این کار از انباشت بیش از حد خطای انتگرال در زمان‌هایی که عملگر (موتور) به اشباع رسیده است، جلوگیری کرده و پایداری سیستم را به شدت بهبود می‌بخشد.
\end{itemize}
این پیاده‌سازی هوشمندانه، کنترل‌کننده‌ای را فراهم می‌کند که نه تنها دقیق، بلکه در برابر نویز و محدودیت‌های فیزیکی سیستم نیز مقاوم است.



\section{شرح کد \lr{main}}

فایل \lr{main.c} نقطه ورود و مرکز هماهنگی کل پروژه نرم‌افزاری است. این فایل وظیفه دارد تا سخت‌افزار میکروکنترلر را راه‌اندازی کرده، تمام ماژول‌های نرم‌افزاری (شامل \lr{basic}، \lr{mpu9250} و \lr{controller}) را به ترتیب صحیح مقداردهی اولیه نماید و در نهایت، حلقه بی‌نهایت کنترلی را اجرا کند که وظیفه پایدارسازی کوادروتور را بر عهده دارد.

\subsection{فاز راه‌اندازی ($Initialization$)}

پیش از ورود به حلقه اصلی، مجموعه‌ای از دستورات برای آماده‌سازی سیستم اجرا می‌شود. این فرآیند که تنها یک بار در هنگام روشن شدن دستگاه انجام می‌گیرد، شامل مراحل زیر است:
\begin{enumerate}
    \item \textbf{راه‌اندازی سخت‌افزار \lr{HAL}:} ابتدا توابع استاندارد \lr{STM32 HAL} مانند \lr{HAL\_Init()} و \lr{SystemClock\_Config()} فراخوانی می‌شوند. سپس، تمام پریفرال‌های سخت‌افزاری مورد نیاز پروژه که از طریق \lr{CubeMX} پیکربندی شده‌اند، راه‌اندازی می‌گردند. این پریفرال‌ها شامل موارد زیر هستند:
    \begin{itemize}
        \item \lr{I2C1}: برای برقراری ارتباط با سنسور \lr{MPU-9250}.
        \item \lr{TIM2}: به عنوان زمان‌سنج اصلی سیستم با دقت میکروثانیه (مورد استفاده در ماژول \lr{basic}).
        \item \lr{TIM3}: برای تولید چهار کانال سیگنال \lr{PWM} جهت کنترل موتورها (مورد استفاده در ماژول \lr{controller}).
    \end{itemize}

    \item \textbf{راه‌اندازی ماژول‌های نرم‌افزاری:} پس از آماده شدن سخت‌افزار، ماژول‌های نرم‌افزاری به ترتیب فراخوانی می‌شوند:
    \begin{itemize}
        \item \lr{module\_00\_basic\_init()}: تایمر سیستم را برای زمان‌بندی دقیق فعال می‌کند.
        \item \lr{module\_01\_controller\_init()}: تایمر \lr{PWM} را برای ارسال سیگنال به موتورها فعال می‌کند.
        \item \lr{MPU9250\_Init()}: سنسور \lr{IMU} را راه‌اندازی کرده و از صحت ارتباط با آن اطمینان حاصل می‌کند.
    \end{itemize}

    \item \textbf{کالیبراسیون سنسور:} در صورتی که راه‌اندازی سنسور موفقیت‌آمیز باشد، تابع \lr{MPU9250\_Calibrate\_Gyro} با استفاده از ۵۰۰ نمونه فراخوانی می‌شود. این مرحله برای حذف خطای بایاس ژیروسکوپ و دستیابی به تخمین دقیق زاویه \lr{Yaw} بسیار حیاتی است.
\end{enumerate}

\subsection{حلقه کنترل اصلی (\lr{The Main Control Loop})}
\label{ssec:main_loop}

پس از اتمام فاز راه‌اندازی، برنامه وارد یک حلقه بی‌نهایت \lr{while(1)} می‌شود. این حلقه، قلب تپنده سیستم کنترل پرواز است و وظایف خود را به صورت پیوسته و با سرعت بالا تکرار می‌کند. ترتیب اجرای توابع در این حلقه برای عملکرد صحیح سیستم بسیار مهم است:
\begin{enumerate}
    \item \textbf{\lr{module\_00\_basic\_loop\_handler()}}: در ابتدای هر تکرار، این تابع فراخوانی می‌شود تا زمان سیستم به‌روز شده و فاصله زمانی از حلقه قبلی (\lr{dt}) محاسبه شود.

    \item \textbf{\lr{module\_01\_controller\_loop\_handler()}}: در این مرحله، الگوریتم‌های کنترل \lr{PID} اجرا می‌شوند. این ماژول بر اساس \textit{آخرین داده‌های معتبر سنسور} (که در تکرار قبلی حلقه خوانده شده‌اند) و با استفاده از \lr{dt} محاسبه‌شده، خروجی‌های کنترلی را محاسبه کرده و فرمان \lr{PWM} جدید را به موتورها ارسال می‌کند.

    \item \textbf{\lr{MPU9250\_Read\_All()}}: پس از اجرای منطق کنترل، داده‌های جدید از سنسور \lr{IMU} خوانده شده و با اجرای فیلتر کالمن، مقادیر جدید و به‌روزشده برای زوایای \lr{Roll}، \lr{Pitch} و \lr{Yaw} محاسبه می‌شوند.

    \item \textbf{به‌روزرسانی متغیرهای سراسری:} در انتهای حلقه، مقادیر جدید محاسبه‌شده از سنسور، در متغیرهای سراسری \lr{Roll}، \lr{Pitch} و \lr{Yaw} کپی می‌شوند. این کار تضمین می‌کند که در \textit{تکرار بعدی حلقه}، ماژول کنترل‌کننده به جدیدترین اطلاعات وضعیت دسترسی خواهد داشت.
\end{enumerate}
این چرخه که به آن «حس کن - فکر کن - عمل کن» (\lr{Sense-Think-Act}) گفته می‌شود، اساس کار تمام سیستم‌های رباتیک و کنترلی بلادرنگ را تشکیل می‌دهد.

\subsection{مدیریت وقفه‌ها (\lr{Interrupt Handling})}
\label{ssec:main_interrupt}

تابع \lr{HAL\_TIM\_PeriodElapsedCallback} یک تابع بازخوانی (\lr{Callback}) است که به صورت خودکار توسط سخت‌افزار و در زمان وقوع یک \textbf{وقفه ($Interrupt$)} فراخوانی می‌شود. در این پروژه، این تابع زمانی اجرا می‌شود که تایمر \lr{TIM2} سرریز شود. این تابع، رویداد سرریز را به ماژول \lr{basic} (از طریق تابع \lr{module\_00\_basic\_tim\_interrupt\_handler}) اطلاع می‌دهد تا شمارنده نرم‌افزاری ۶۴ بیتی به درستی کار کند. این مکانیزم برای پیاده‌سازی یک زمان‌سنج دقیق و بدون خطا ضروری است.

\newpage
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{CH05_PIC/5897954176288279165.jpg}
    \caption{برد استفاده شده برای راه‌اندازی}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{CH05_PIC/5897954176288279164.jpg}
    \caption{کواد به همراه برد استفاده شده}
\end{figure}


\newpage
\chapter{نتیجه‌گیری}
در این پروژه، یک کنترل‌کننده مقاوم \lr{Fuzzy-PID} برای پایدارسازی و ردیابی مسیر یک کوادروتور طراحی، شبیه‌سازی و ارزیابی گردید. هدف اصلی، غلبه بر چالش‌های ذاتی سیستم‌های کوادروتور، شامل دینامیک شدیداً غیرخطی، کوپلینگ بین حرکات دورانی و انتقالی، و ناپایداری حلقه-باز بود.

تحقیقات اولیه با مرور جامع ادبیات و تحلیل سیر تکامل روش‌های کنترلی آغاز شد. این بررسی نشان داد که کنترل‌کننده‌های خطی کلاسیک نظیر $PID$، علی‌رغم سادگی پیاده‌سازی، در مواجهه با مانورهای تهاجمی و تغییرات دینامیکی سیستم، عملکرد مطلوبی ندارند و دچار ناپایداری می‌شوند. این ضعف ذاتی، انگیزه‌ی اصلی برای انتخاب یک معماری کنترلی هوشمند و تطبیقی بود. بر این اساس، ساختار \lr{Fuzzy-PID} به دلیل قابلیت تنظیم آنلاین و هوشمند بهره‌های کنترلی بر اساس شرایط لحظه‌ای پرواز انتخاب شد تا پاسخی سریع، دقیق و در عین حال پایدار فراهم آورد.

برای اعتبارسنجی عملی، یک محیط شبیه‌سازی جامع در بستر \lr{MATLAB/Simulink} توسعه یافت. ابتدا، مدل دینامیکی کوادروتور با استفاده از یک رابط گرافیکی سفارشی که پارامترهای فیزیکی دقیق قطعات را دریافت می‌کرد، ایجاد شد. سپس، یک ساختار کنترلی آبشاری، متشکل از حلقه داخلی کنترل وضعیت و حلقه خارجی کنترل موقعیت، پیاده‌سازی شد. عملکرد کنترل‌کننده در سه سناریوی آزمون استاندارد ارزیابی شد: مسیر دایره‌ای برای سنجش پایداری پایه، مسیر هشتی برای آزمون مانورپذیری، و مسیر لوزی برای تحلیل پاسخ گذرا به تغییرات ناگهانی.

نتایج شبیه‌سازی کنترل‌کننده $PID$ استاندارد، ضعف‌های پیش‌بینی‌شده را تأیید کرد؛ سیستم در پاسخ به فرمان‌های پله‌ای دچار فراجهش ($Overshoot$) بزرگ، نوسانات شدید و زمان نشست طولانی می‌شد که نشان‌دهنده یک عملکرد زیرمیرا ($Underdamped$) و نامطلوب بود. در مقابل، کنترل‌کننده \lr{Fuzzy-PID} که با استفاده از یک سیستم استنتاج فازی بهره‌های خود را به صورت پویا تنظیم می‌کرد، بهبود عملکردی چشمگیری را به نمایش گذاشت. فراجهش و نوسانات به طور کامل حذف شدند، زمان نشست به شدت کاهش یافت و دقت ردیابی مسیر به طور قابل توجهی افزایش پیدا کرد. مقایسه‌ی کمی با استفاده از معیارهای خطای $MSE$ و $ITAE$، برتری قاطع کنترل‌کننده \lr{Fuzzy-PID} را در تمامی محورها به اثبات رساند و نشان داد که این رویکرد توانسته است تعادل موفقی بین سرعت پاسخ و پایداری ایجاد کند.

در مجموع، این پروژه با موفقیت نشان داد که ترکیب منطق فازی با ساختار کلاسیک $PID$ یک راهکار مؤثر برای کنترل مقاوم و با عملکرد بالای کوادروتورها است. این کنترل‌کننده هوشمند با تطبیق‌پذیری خود، ضعف‌های ذاتی کنترل‌کننده‌های با بهره ثابت را برطرف کرده و یک بستر قابل اعتماد برای پیاده‌سازی نهایی بر روی سخت‌افزار واقعی فراهم می‌آورد.

% ------------------ مراجع ------------------
\addcontentsline{toc}{chapter}{مراجع}
\pagestyle{empty}
{
\small
\onehalfspacing
\bibliographystyle{unsrt-fa}
\bibliography{references}
}

\end{document}